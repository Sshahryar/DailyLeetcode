# Leetcode

Repository of my Leetcode journey, starting September 23, 2023. 

Including my solutions for daily challenges, problems and contests. 

Leetcode is a website for technical interview preparation that offers coding problems, challenges, contests, enhancement of problem-solving skills, algorithms and data structures. 

My profile is linked below:

https://leetcode.com/Sshahryar/

Below will be updates on the Daily Challenge Solutions**. Info on other folders in the repository such as courses, challenges, etc. can be found in the wiki. 

**The daily challenge updates are based on this title format: Solution (date) (language, leetcode) (name of challenge) (difficulty). 

**The daily challenge solutions are designed to work on the leetcode, and may or may not work on ide's outside of 
leetcode, because of test cases and specific parameters. 

## Leetcode Daily Challenge Solutions (From .LeetcodeDailySolution)

### Solution Sept 23, 2023 (Java, leetcode) 1048. LongestStrChain (Medium) 

In .LeetcodeDailySolution folder as Sept23,2023.java

#### Prompt:

You are given an array of words where each word consists of lowercase English letters.

wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.

For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".
A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.

Return the length of the longest possible word chain with words chosen from the given list of words.

#### Solution:

    class Solution {
        public int longestStrChain(String[] words) {
            int ans = 0;
            Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));
        
        Map<String, Integer> dp = new HashMap<String, Integer>();
        
        for (String w: words) {
            int best = 0;
            for (int i = 0; i < w.length(); i++) {
                String prev = w.substring(0, i) + w.substring(i + 1);
                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);
            }
            dp.put(w, best);
            ans = Math.max(ans, best);
        }
        return ans;
    }
    }

Runtime: 41 ms, beating 31.27% of leetcode users solutions using java.
Memory: 43.9 mb, beating 34.67% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, arrays, map, and hashmap.
    
### Solution Sept 25, 2023 (Java, leetcode) 389. Find the Difference (Easy)
In .LeetcodeDailySolution folder as Sept25,2023.java

#### Prompt:

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

#### Solution:

    class Solution {
        public char findTheDifference(String s, String t) {
            int[] charCount = new int[26];
        
        for (char c : s.toCharArray()) {
            charCount[c - 'a']++;
        }
        
        for (char c : t.toCharArray()) {
            charCount[c - 'a']--;
        }
        
        for (int i = 0; i < 26; i++) {
            if (charCount[i] < 0) {
                return (char) (i + 'a');
            }
        }
        
        return ' ';
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String s = "abcd";
        String t = "abcde";
        char addedLetter = solution.findTheDifference(s, t);
        System.out.println("The added letter is: " + addedLetter);
    }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 40.9 mb, beating 20.52% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays and for loop. 

### Solution Sept 26, 2023 (Java, leetcode) 316. Remove Duplicate Letters (Medium) 
In .LeetcodeDailySolution folder as Sept26,2023.java

#### Prompt:

Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is 
the smallest in lexicographical order among all possible results.
 
#### Solution:

    import java.util.Stack;

    class Solution {
    public String removeDuplicateLetters(String s) {
        int[] count = new int[26];
        boolean[] used = new boolean[26];
        Stack<Character> stack = new Stack<>();

        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }

        for (char c : s.toCharArray()) {
            count[c - 'a']--;
            if (used[c - 'a']) {
                continue;
            }

            while (!stack.isEmpty() && c < stack.peek() && count[stack.peek() - 'a'] > 0) {
                used[stack.pop() - 'a'] = false;
            }

            stack.push(c);
            used[c - 'a'] = true;
        }

        StringBuilder result = new StringBuilder();
        for (char c : stack) {
            result.append(c);
        }

        return result.toString();
    }
    }
    
Runtime: 2 ms, beating 96.27% of leetcode users solutions using java.
Memory: 41.1 mb, beating 62.98% of leetcode users solutions using java.

#### Concepts Applied:

CharacterArray and stack. 

### Solution Sept 27, 2023 (Java, leetcode) 880. Decoded String at Index (Medium)
In .LeetcodeDailySolution folder as Sept27,2023.java

#### Prompt:

You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:

If the character read is a letter, that letter is written onto the tape.
If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.
Given an integer k, return the kth letter (1-indexed) in the decoded string.

#### Solution:

    class Solution {
    public String decodeAtIndex(String encodedString, int k) {
       Stack<Long> characterLengths = new Stack<>();

        characterLengths.push(0L); 

        for (int i = 0; i < encodedString.length(); i++) {
            char c = encodedString.charAt(i);
            if (Character.isDigit(c)) {

                long length = characterLengths.peek() * (c - '0');
                characterLengths.push(length);
            } else {

                long length = characterLengths.peek() + 1;
                characterLengths.push(length);
            }
        }

        int ln = characterLengths.size();
        while (!characterLengths.isEmpty()) {
            k %= characterLengths.peek(); 
            ln--;

            if (k == 0 && Character.isLetter(encodedString.charAt(ln - 1))) {
                return String.valueOf(encodedString.charAt(ln - 1));
            }


            characterLengths.pop();
        }

        return ""; 
    }
    }

Runtime: 1 ms, beating 13.46% of leetcode users solutions using java.
Memory: 40.8 mb, beating 8.48% of leetcode users solutions using java.

#### Concepts Applied:

Strings, stack, character lengths, e.t.c

### Solution Sept 28, 2023 (Java, leetcode) 905. Sort Array by Parity (Easy)
In .LeetcodeDailySolution folder as Sept28,2023.java

#### Prompt:

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

#### Solution:

    class Solution {
      public int[] sortArrayByParity(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            if (nums[left] % 2 == 0) {
                left++;  

            } else if (nums[right] % 2 == 1) {
                right--;  

            } else {
                
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
                right--;
            }
        }

        return nums;
     }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 44.1 mb, beating 40.77% of leetcode users solutions using java.

#### Concepts Applied:

While loop, if and else-if. 

### Solution Sept 29, 2023 (Java, leetcode) 896. Monotonic Array (Easy)
In .LeetcodeDailySolution folder as Sept29,2023.java

#### Prompt: 

An array is monotonic if it is either monotone increasing or monotone decreasing.

An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].

Given an integer array nums, return true if the given array is monotonic, or false otherwise.

#### Solution:

    class Solution {
       public boolean isMonotonic(int[] nums) {
        boolean increasing = true;
        boolean decreasing = true;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i - 1] > nums[i]) {
                increasing = false; 
            } else if (nums[i - 1] < nums[i]) {
                decreasing = false; 
            }
            
            if (!increasing && !decreasing) {
                return false;
            }
        }

        return true; 
      }
    }

Runtime: 2 ms, beating 58.97% of leetcode users solutions using java.
Memory: 54.4 mb, beating 73.26% of leetcode users solutions using java.

#### Concepts Applied:

Booleans, for loop, if, and else-if. 

### Solution Sept 30, 2023 (Java, leetcode) 456. 132 Pattern (Medium)
In .LeetcodeDailySolution folder as Sept30,2023.java

#### Prompt:

Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].

Return true if there is a 132 pattern in nums, otherwise, return false.

Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
 
Constraints:

n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109

#### Solution:

    import java.util.Stack;

    class Solution {
       public boolean find132pattern(int[] nums) {
        int n = nums.length;
        int[] minLeft = new int[n];
        minLeft[0] = nums[0];
        
        for (int i = 1; i < n; i++) {
            minLeft[i] = Math.min(minLeft[i - 1], nums[i]);
        }
        
        Stack<Integer> stack = new Stack<>();
        
        for (int j = n - 1; j >= 0; j--) {
            if (nums[j] > minLeft[j]) {
                while (!stack.isEmpty() && stack.peek() <= minLeft[j]) {
                    stack.pop();
                }
                if (!stack.isEmpty() && stack.peek() < nums[j]) {
                    return true;
                }
                stack.push(nums[j]);
            }
        }
        
        return false;
      }
    }

Runtime: 15 ms, beating 68.8% of leetcode users solutions using java.
Memory: 64.1 mb, beating 8.57% of leetcode users solutions using java.

#### Concepts Applied:

Stack, for and while loop. 

### Solution Oct 1, 2023 (Java, leetcode) 557. Reverse Words In a String III (Easy) 
In .LeetcodeDailySolution folder as Oct1,2023.java

#### Prompt:

Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

Example 1:

Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
Example 2:

Input: s = "God Ding"
Output: "doG gniD"

Constraints:

1 <= s.length <= 5 * 104
s contains printable ASCII characters.
s does not contain any leading or trailing spaces.
There is at least one word in s.
All the words in s are separated by a single space.

#### Solution:

    class Solution {
       public String reverseWords(String s) {
          String[] words = s.split(" "); 

        StringBuilder result = new StringBuilder();

        for (String word : words) {
            
            result.append(reverseWord(word)).append(" ");
        }

        return result.toString().trim(); 

    }

    private String reverseWord(String word) {
        char[] chars = word.toCharArray(); 
        int left = 0;
        int right = chars.length - 1;

        while (left < right) {

            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;

            left++;
            right--;
        }

        return new String(chars); 
      }
    }

Runtime: 4 ms, beating 87.77% of leetcode users solutions using java.
Memory: 43.9 mb, beating 85.88% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays, for and while loop. 

### Solution Oct 2, 2023 (Java, leetcode) 2038. Remove Colored Pieces if Both Neighbors are the Same (Medium) 
In .LeetcodeDailySolution folder as Oct2,2023.java

#### Prompt:

There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.

Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.

Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
Alice and Bob cannot remove pieces from the edge of the line.
If a player cannot make a move on their turn, that player loses and the other player wins.
Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.

#### Solution:

    class Solution {
      public boolean winnerOfGame(String colors) {
        int n = colors.length();
        int aliceCount = 0;
        int bobCount = 0;
        
        for (int i = 1; i < n - 1; i++) {
            if (colors.charAt(i) == 'A' && colors.charAt(i - 1) == 'A' && colors.charAt(i +         1) == 'A') {
                aliceCount++;
            } else if (colors.charAt(i) == 'B' && colors.charAt(i - 1) == 'B' && colors.    charAt(i + 1) == 'B') {
                bobCount++;
            }
        }
        
        return aliceCount > bobCount;
      }
    }

Runtime: 16 ms, beating 52.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 55.98% of leetcode users solutions using java. 

#### Concepts Applied:

Strings, for loop, if, else-if, and charAt. 

### Solution Oct 3, 2023 (Java, leetcode) 1512. Number of Good Pairs (Easy) 
In .LeetcodeDailySolution folder as Oct3,2023.java

#### Prompt:

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

#### Solution:

    class Solution {
       public int numIdenticalPairs(int[] nums) {
           int[] count = new int[101]; 

        for (int num : nums) {
            count[num]++;
        }
        
        int goodPairs = 0;
        
        for (int c : count) {
            if (c > 1) {
                goodPairs += (c * (c - 1)) / 2;
            }
        }
        
        return goodPairs;
      }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40 mb, beating 34.61% of leetcode users solutions using java. 

#### Concepts Applied:

For loop.

### Solution Oct 4, 2023 (Java, leetcode) 706. Design HashMap (Easy)
In .LeetcodeDailySolution folder as Oct4,2023.java

#### Prompt:

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

#### Solution

    import java.util.ArrayList;
    import java.util.List;
  
    class MyHashMap {

    private static final int SIZE = 1000;
    private List<List<int[]>> data;

    public MyHashMap() {
        data = new ArrayList<>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            data.add(new ArrayList<>());
        }
    }

    private int getIndex(int key) {
        return Integer.hashCode(key) % SIZE;
    }

    public void put(int key, int value) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                entry[1] = value;
                return;
            }
        }
        data.get(index).add(new int[]{key, value});
    }

    public int get(int key) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                return entry[1];
            }
        }
        return -1;
    }

    public void remove(int key) {
        int index = getIndex(key);
        List<int[]> entries = data.get(index);
        for (int i = 0; i < entries.size(); i++) {
            if (entries.get(i)[0] == key) {
                entries.remove(i);
                return;
            }
        }
      }
    }

    public class Main {
      public static void main(String[] args) {
        MyHashMap myHashMap = new MyHashMap();
        myHashMap.put(1, 1);
        myHashMap.put(2, 2);
        System.out.println(myHashMap.get(1)); 
        System.out.println(myHashMap.get(3)); 
        myHashMap.put(2, 1);
        System.out.println(myHashMap.get(2)); 
        myHashMap.remove(2);
        System.out.println(myHashMap.get(2)); 
      }
    }

Runtime: 17 ms, beating 65.77% of leetcode users using java.
Memory: 47.6 mb, beating 69.68% of leetcode users using java.

#### Concepts Applied:

Array, hash table, linked list, design, and hash function.

### Soluton Oct 5, 2023 (Java, leetcode) 229. Majorty Element II (Medium)
In .LeetcodeDailySolution folder as Oct5,2023.java

#### Prompt:

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

#### Solution:

    import java.util.ArrayList;
    import java.util.List;

    class Solution {
      public List<Integer> majorityElement(int[] nums) {
        List<Integer> result = new ArrayList<>();
        int n = nums.length;

        if (n == 0) return result;

        int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;

        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            } else if (count1 == 0) {
                candidate1 = num;
                count1 = 1;
            } else if (count2 == 0) {
                candidate2 = num;
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }

        count1 = 0;
        count2 = 0;
        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            }
        }

        if (count1 > n / 3) {
            result.add(candidate1);
        }
        if (count2 > n / 3) {
            result.add(candidate2);
        }

        return result;
      }
    }

Runtime: 1 ms, beating 99.94% of leetcode users solutions using java. 
Memory: 47.2 mb, beating 10.66% of leetcode users solutions using java.

#### Concepts Applied:

Array, hash table, sorting, and counting.

### Solution Oct 6, 2023 (Java, leetcode) 343. Integer Break (Medium)
In .LeetcodeDailySolution folder as Oct6,2023.java

#### Prompt:

Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

Return the maximum product you can get.

#### Solution:

    class Solution {
        public int integerBreak(int n) {
                if(n == 1) return 1;
                        int[] dp = new int[n + 1];
                                dp[1] = 1;
                                        for(int i = 2; i <= n; i++){
                                                    for(int j = 1; j < i; j++){
                                                                    dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                                                                                }
                                                                                        }
                                                                                                return dp[n];
                                                                                                    }
                                                                                                    }
                                                                                                    
Runtime: 1 ms, beating 33.22% of leetcode users solutions using java.
Memory: 39.9 mb, beating 6.52% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming and for loop.

### Solution Oct 7, 2023 (Java, leetcode) 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons (Hard)
Im .LeetcodeDailySolution folder as Oct7,2023.java

#### Prompt:

You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/213847ce-4a27-441a-9b8a-06910e1736ce)

You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.

#### Solution:

    class Solution {
        public int numOfArrays(int n, int m, int k) {
        long[][][] dp = new long[n][k][m];
        long mod = 1000000007;
        Arrays.fill(dp[0][0], 1);
        
        for (int i = 1; i < n; i++) {
            for (int cost = 0; cost < Math.min(i + 1, k); cost++) {
                for (int max = 0; max < m; max++) {
                    dp[i][cost][max] = (dp[i][cost][max] + (max + 1) * dp[i - 1][cost][max]) % mod;
                    if (cost != 0) {
                        long sum = 0;
                        for (int prevMax = 0; prevMax < max; prevMax++) {
                            sum += dp[i - 1][cost - 1][prevMax];
                            sum %= mod;
                        }
                        dp[i][cost][max] = (dp[i][cost][max] + sum) % mod;
                    }
                }
            }
        }
        long ans = 0;
        for (int max = 0; max < m; max++) {
            ans += dp[n - 1][k - 1][max];
            ans %= mod;
        }
        return (int) ans;
      }
    }

Runtime: 27 ms, beating 85.37% of leetcode users solutions using java.
Memory: 43.6 mb, beating 24.29% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, dynamic programming, and if statements.

### Solution Oct 8, 2023 (Java, leetcode) 1458. Max Dot Product of Two Subtances (Hard)
In .LeetcodeDailySolutions folder as Oct8,2023.java

#### Prompt:

Given two arrays nums1 and nums2.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).

#### Solution:

    class Solution {
        public int maxDotProduct(int[] nums1, int[] nums2) {
        int[][] marks = new int[nums1.length][nums2.length];
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                int max = nums1[i] * nums2[j];
                if (i > 0 && j > 0) {
                    max = Math.max(max, max + marks[i - 1][j - 1]);
                }
                if (i > 0) {
                    max = Math.max(max, marks[i - 1][j]);
                }
                if (j > 0) {
                    max = Math.max(max, marks[i][j - 1]);
                }
                marks[i][j] = max;
            }
        }
        return marks[nums1.length - 1][nums2.length - 1];
      }
    }
    
Runtime: 10 ms, beating 81.94% of leetcode users solutions using java.
Memory: 42.9 mb, beating 80.56% of leetcode users solutions using java.

#### Concepts Applied:

Math, for-loop and if statements.

### Solution Oct 9, 2023 (Java, leetcode) 34. Find First and Last Position of Element in Sorted Array (Medium)
In .LeetcodeDailySolution folder as Oct9,2023.java

#### Prompt:

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

#### Solution:

    class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first = -1, last = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                if (first == -1) {
                    first = i;
                }
                last = i;
            }
        }
        return new int[]{first, last};
      }
    }

Runtime: 1 ms, beating 20.94% of leetcode users solutions using java.
Memory: 44.1 mb, beating 82.90% of leetcode users solutions using java. 

#### Concepts Applied:

If statements.

### Solution Oct 10, 2023 (Java, leetcode) 2009. Minimum Number of Operation to Make Array Continuous
In .LeetcodeDailySolution folder as Oct10,2023.java

#### Prompt:

You are given an integer array nums. In one operation, you can replace any element in nums with any integer.

nums is considered continuous if both of the following conditions are fulfilled:

All elements in nums are unique.
The difference between the maximum element and the minimum element in nums equals nums.length - 1.
For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.

Return the minimum number of operations to make nums continuous.

#### Solution:

    class Solution {
      public int minOperations(int[] nums) {
        Arrays.sort(nums);
        int uniqueLen = 1;
        for (int i = 1; i < nums.length; ++i) {
            if (nums[i] != nums[i - 1]) {
                nums[uniqueLen++] = nums[i];
            }
        }
        
        int ans = nums.length;
        for (int i = 0, j = 0; i < uniqueLen; ++i) {
            while (j < uniqueLen && nums[j] - nums[i] <= nums.length - 1) {
                ++j;
            }
            ans = Math.min(ans, nums.length - (j - i));
        }
        
        return ans;
      }
    }

Runtime: 36 ms, beating 99.3% of leetcode users solutions using java.
Memory: 58 mb, beating 43.69% of leetcode users solutons using java.

#### Concepts Applied:

Arrays, for loop, while loop, and if statements.

### Solution Oct 11, 2023 (Java, leetcode) 2251. Numbers of Flowers in Full Bloom (Hard)
In .LeetcodeDailySolution folder as Oct11,2023.java

#### Prompt: 

You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the ith person will arrive to see the flowers.

Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.

Example 1:

Input: flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]
Output: [1,2,2,2]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

Example 2:

Input: flowers = [[1,10],[3,3]], people = [3,3,2]
Output: [2,2,1]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

#### Solution:

    class Solution {
    public int[] fullBloomFlowers(int[][] flowers, int[] persons) {
        int n = persons.length;
        int[] result = new int[n];

        TreeMap<Integer, Integer> treeMap = new TreeMap<>();
        for (int i = 0; i < flowers.length; i++) {
        
            treeMap.put(flowers[i][0], treeMap.getOrDefault(flowers[i][0], 0) + 1);

            treeMap.put(flowers[i][1] + 1, treeMap.getOrDefault(flowers[i][1] + 1, 0) - 1);
        }
        
        TreeMap<Integer, Integer> sum = new TreeMap<>();
        int prev = 0;
        for (Map.Entry<Integer, Integer> entry : treeMap.entrySet()) {
            prev += entry.getValue();
            sum.put(entry.getKey(), prev);
        }

        for (int i = 0; i < n; i++) {

            Map.Entry<Integer, Integer> entry = sum.floorEntry(persons[i]);
            if (entry != null) {
                result[i] = entry.getValue(); 
            }
        }
        return result;
        }
    }

Runtime: 102 ms, beating 19.78% of leetcode users using java.
Memory: 73.5 mb, beating 22.1% of leetcode users using java.

#### Concepts Applied:

Treemap, for loop, and if statements. 

### Solution Oct 12, 2023 (Java, leetcode) 1095. Find in Mountain Array (Hard)
In .LeetcodeDailySolution folder as Oct12,2023.java

#### Prompt:

(This problem is an interactive problem.)

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.

You cannot access the mountain array directly. You may only access the array using a MountainArray interface:

MountainArray.get(k) returns the element of the array at index k (0-indexed).
MountainArray.length() returns the length of the array.
Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.

#### Solution:
     
    class Solution {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int length = mountainArr.length();
        int peakIndex = findPeak(mountainArr, length);

        int result = findTarget(mountainArr, 0, peakIndex, target, true);
        if (result != -1) {
            return result;
        }

        return findTarget(mountainArr, peakIndex + 1, length - 1, target, false);
    }

    private int findTarget(MountainArray mountainArr, int left, int right, int target, boolean isUpside) {
        while (left <= right) {
            int mid = (left + right) / 2;
            int midVal = mountainArr.get(mid);

            if (midVal == target) {
                return mid;
            }

            if (isUpside) {
                if (target > midVal) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else {
                if (target > midVal) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }

        return -1;
    }

    private int findPeak(MountainArray mountainArr, int length) {
        int left = 0;
        int right = length - 1;

        while (left < right) {
            int mid = (left + right) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.9 mb, beating 85.75% of leetcode users solutions using java.

#### Concepts Applied: 

Dynamic programming, math and for loop.

### Solution Oct 13, 2023 (Java, leetcode) 746. Min Cost Climbing Stairs (Easy)
In .LeetcodeDailySolution folder as Oct13,2023.java

#### Prompt:

You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

#### Solution:

    class Solution {

    public int minCostClimbingStairs(int[] cost) {

        int n = cost.length;

        int[] dp = new int[n];

        dp[0] = cost[0];

        dp[1] = cost[1];

        

        for (int i = 2; i < n; i++) {

            dp[i] = cost[i] + Math.min(dp[i-1], dp[i-2]);

        }

        

        return Math.min(dp[n-1], dp[n-2]);

        }

    }
    
Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.1 mb, beating 24.85% of leetcode users solutions using java.

#### Concepts Applied:

Dyanmic programming, math and for loop.

### Solution Oct 14, 2023 (Java, leetcode) 2742. Painting the Walls (Hard)
In .LeetcodeDailySolution folder as Oct14,2023.java

#### Prompt:

You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:

A paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.
A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.
Return the minimum amount of money required to paint the n walls.

#### Solution:

    class Solution {
    public int paintWalls(int[] cost, int[] time) {
        int n = cost.length;
        int[] money = new int[n+1];
        Arrays.fill(money,(int)1e9);
        money[0]=0;
        for(int i=0;i<n;i++)
        {
            for(int j=n;j>0;j--)
            {
                money[j]=Math.min(money[j],money[Math.max(j-time[i]-1,0)]+cost[i]);
            }
        }
        return money[n];
        }
    }

Runtime: 8 ms, beating 98.47% of leetcode users solutions using java.
Memory: 43.3 mb, beating 95.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, math and for loop. 

### Solution Oct 15, 2023 (Java, leetcode) 1269. Number of Ways to Stay in the Same Place After Some Steps (Hard)
In .LeetcodeDailySolution as Oct15,2023.java

#### Prompts:

You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).

Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int numWays(int steps, int arrLen) {
        int m = steps;
        int n = Math.min(steps / 2 + 1, arrLen);
        
        int[][] dp = new int[m + 1][n];
        dp[0][0] = 1;
        
        int mod = 1000000007;
        
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j > 0) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
                }
                if (j < n - 1) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;
                }
            }
        }
        
        return dp[m][0];
        }
    }

Runtime: 9 ms, beating 67.90% of leetcode users solutions using java.
Memory: 42.1 mb, beating 89.20% of leetcode users solutions using java.

#### Concepts Applied:

Math, dynamic programming, for loops, and if statements.

### Solution Oct 16, 2023 (Java, leetcode) 119. Pascals Triangle II (Easy) 
In .LeetcodeDailySolution folder as Oct16,2023.java

#### Prompt:

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/4de7c43b-3fb2-43b2-8d4f-806d74ff3e22)

#### Solution:

    class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<>();

        res.add(1);
        long prev = 1;

        for (int k = 1; k<= rowIndex; k++) {
            long next_val = prev * (rowIndex - k+1) / k;
            res.add((int) next_val);
            prev = next_val;

        }
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.9 mb, beating 78.30% of leetcode users solutions using java.

#### Concepts Applied:

Lists and for loop.

### Solution Oct 17, 2023 (Java, leetcode) 1361. Validate Binary Tree Nodes (Medium)
In. LeetcodeDailySolution folder as Oct17,2023.java

#### Prompt:

You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.

If node i has no left child then leftChild[i] will equal -1, similarly for the right child.

Note that the nodes have no values and that we only use the node numbers in this problem.

#### Solution:

    class Solution {
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        int[] indegree = new int[n];
        for (int i = 0; i < n; i++) {
            if (leftChild[i] != -1) indegree[leftChild[i]]++;
            if (rightChild[i] != -1) indegree[rightChild[i]]++;
        }
        int root = -1;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                if (root == -1) root = i;
                else return false;
            }
        }
        if (root == -1) return false;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (visited[node]) return false;
            visited[node] = true;
            if (leftChild[node] != -1) queue.offer(leftChild[node]);
            if (rightChild[node] != -1) queue.offer(rightChild[node]);
        }
                int trueCount = 0;
        for (boolean b : visited) {
            if (b) trueCount++;
        }
        return trueCount == n;

        }
    }

Runtime: 5 ms, beating 76.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 91.61% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statements, linked lists, and while loop.

### Solution Oct 18, 2023 (Java, leetcode) 2050, Parallel Courses III (Hard)
In .LeetcodeDailySolution folder as Oct18,2023.java

#### Prompt:

You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.

You must find the minimum number of months needed to complete all the courses following these rules:

You may start taking a course at any time if the prerequisites are met.
Any number of courses can be taken at the same time.
Return the minimum number of months needed to complete all the courses.

Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).

#### Solution:

    class Solution {
    private int[] startNodes;
    private int[][] graph;
    private int[] time;
    private boolean[] visited;
    private int[] ans;

    private void toGraph(int[][] edges, int n) {
        int[] incoming = new int[n], outgoing = new int[n];
        for(int[] e : edges) {
            outgoing[e[0] - 1]++;
            incoming[e[1] - 1]++;
        }
        int startCnt = 0;
        for(int i : incoming) {
            if (i == 0) {
                startCnt++;
            }
        }
        startNodes = new int[startCnt];
        for(int sni = 0, i = 0; sni < startNodes.length; i++) {
            if (incoming[i] == 0) {
                startNodes[sni++] = i;
            }
        }
        graph = new int[n][];
        for(int i = 0; i < n; i++) {
            graph[i] = new int[outgoing[i]];
        }
        for(int[] e : edges) {
            graph[e[0] - 1][--outgoing[e[0] - 1]] = e[1] - 1;
        }
    }

    private int calculate(int node) {
        if (ans[node] > 0) {
            return ans[node];
        }

        int worstPrereq = 0;
        visited[node] = true;
        for(int child : graph[node]) {
            if (!visited[child]){
                worstPrereq = Math.max(calculate(child), worstPrereq);
            }
        }
        visited[node] = false;
        return ans[node] = worstPrereq + time[node];
    }

    public int minimumTime(int n, int[][] relations, int[] time) {
        toGraph(relations, n);
        this.time = time;
        ans = new int[n];
        visited = new boolean[n];
        int longest = 0;
        for(int node : startNodes) {
            longest = Math.max(longest, calculate(node));
        }
        return longest;
        }
    }

Runtime: 13 ms, beating 99.56% of leetcode users solutions using java.
Memory: 68 mb, beating 56.45% of leetcode users solutions using java.

#### Concepts Applied:

Graphs, boolean, and for loops.

### Solution Oct 19, 2023 (Java, leetcode) 844. Backspace String Compare (Easy)
In .LeetcodeDailySolution folder as Oct19,2023.java

#### Prompt:

Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

#### Solution:

    class Solution {
    public boolean backspaceCompare(String s, String t) {
        int ps = s.length() - 1;
        int pt = t.length() - 1;

        while (ps >= 0 || pt >= 0) {
            ps = get_next_valid_char_index(s, ps);
            pt = get_next_valid_char_index(t, pt);

            if (ps < 0 && pt < 0) {
                return true;
            }
            if (ps < 0 || pt < 0) {
                return false;
            } else if (s.charAt(ps) != t.charAt(pt)) {
                return false;
            }

            ps--;
            pt--;
        }

        return true;        
    }

    private int get_next_valid_char_index(String str, int end) {
        int backspace_count = 0;
        while (end >= 0) {
            if (str.charAt(end) == '#') {
                backspace_count++;
            } else if (backspace_count > 0) {
                backspace_count--;
            } else {
                break;
            }
            end--;
        }
        return end;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.5 mb, beating 67.63% of leetcode users solutions using java.

#### Concepts Applied:

CharAt, while loop, if, else and else-if statements.

### Solution Oct 20, 2023 (Java, leetcode) 341. Flatten Nested List Iterator
In .LeetcodeDailySolution folder as Oct20,2023.java

#### Prompt:

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:

NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
int next() Returns the next integer in the nested list.
boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:

initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
If res matches the expected flattened list, then your code will be judged as correct.

#### Solution:

    class NestedIterator implements Iterator<Integer> {
    private Stack<NestedInteger> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack = new Stack<>();
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            stack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()) {
            if (stack.peek().isInteger()) {
                return true;
            }
            List<NestedInteger> nestedList = stack.pop().getList();
            for (int i = nestedList.size() - 1; i >= 0; i--) {
                stack.push(nestedList.get(i));
            }
        }
        return false;
        }
    }

Runtime: 4 ms, beating 25.17% of leetcode users solutions using java.
Memory: 44.26 mb, beating 74.13% of leetcode users solutions using java.

#### Concepts Applied:

NestedIterator, Iterators, Stack, nestedList, boolean, and list.

### Solution Oct 21, 2023 (Java, leetcode) 1425. Constrained Subsequence Sum (Hard)
In .LeetcodeDailySolution folder as Oct21,2023.java

#### Prompt:

Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

#### Solution:

    class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        Deque<Integer> queue = new ArrayDeque<>();
        int dp[] = new int[nums.length];
        
        for (int i = 0; i < nums.length; i++) {
            if (!queue.isEmpty() && i - queue.peek() > k) {
                queue.poll();
            }
            
            dp[i] = (!queue.isEmpty() ? dp[queue.peek()] : 0) + nums[i];
            while (!queue.isEmpty() && dp[queue.peekLast()] < dp[i]) {
                queue.pollLast();
            }
            
            if (dp[i] > 0) {
                queue.offer(i);
            }
        }
        
        int ans = Integer.MIN_VALUE;
        for (int num : dp) {
            ans = Math.max(ans, num);
        }
        
        return ans;
        }
    }

Runtime: 33 ms, beating 94.49% of leetcode users solutions using java.
Memory: 56.2 mb, beating 85.83% of leetcode users solutions using java.

#### Concepts Applied:

Deque, dynamic programming, for loop, and if statement.

### Solution Oct 22, 2023 (Java, leetcode) 1793. Maximum Score of a Good Subarray (Hard)
In .LeetcodeDailySolution folder as Oct22,2023.java

#### Prompt:

You are given an array of integers nums (0-indexed) and an integer k.

The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.

Return the maximum possible score of a good subarray.

#### Solution:

    class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int left = k;
        int right = k;
        int ans = nums[k];
        int currMin = nums[k];
        
        while (left > 0 || right < n - 1) {
            if ((left > 0 ? nums[left - 1]: 0) < (right < n - 1 ? nums[right + 1] : 0)) {
                right++;
                currMin = Math.min(currMin, nums[right]);
            } else {
                left--;
                currMin = Math.min(currMin, nums[left]);
            }
            
            ans = Math.max(ans, currMin * (right - left + 1));
        }
        
        return ans;
        }
    }    

Runtime: 7 ms, beating 88.29% of leetcode users solutions using java.
Memory: 59.22 mb, beating 39.39% of leetcode users solutions using java. 

#### Concepts Applied:

While loop, if-statement, else-statement, and math.

### Solution Oct 23, 2023 (Java, leetcode) 342. Power of Four (Easy)
In .LeetcodeDailySolution folder as Oct23,2023.java

#### Prompt:

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

#### Solution:

    class Solution {
       public boolean isPowerOfFour(int n) {
       for(int i = 2 ;i<=32;i+=2){
           if((1<<i) == n) return true;
       }
       return false;
       }
    }
    
Runtime: 1 ms, beating 76.50% of leetcode users solutions using java.
Memory: 39.00 mb, beating 93.98% of leetcode users solutions using java.

#### Concepts Applied:

For loop and if-statement.

### Solution Oct 24, 2023 (Java, leetcode) 515. Find Largest Value in Each Tree Row (Medium)
In .LeetcodeDailySolution folder as Oct24,2023.java

#### Prompt:

Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).

Example 1:

Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
Example 2:

Input: root = [1,2,3]
Output: [1,3]
 
Constraints:

The number of nodes in the tree will be in the range [0, 104].
-231 <= Node.val <= 231 - 1

#### Solution:

    class Solution {
    public List<Integer> largestValues(TreeNode root) {
       Map <Integer , Integer> map = new HashMap(); 
       dfs(root, 0, map);
       return new ArrayList(map.values());
    }

    private void dfs(TreeNode root, int level, Map<Integer , Integer> map){
        if(root==null) return;

        map.put(level, Math.max(root.val, map.getOrDefault(level, Integer.MIN_VALUE)));
        dfs(root.left, level+1, map);
        dfs(root.right, level+1, map);
        }
    }

Runtime: 1 ms, beating 98.02% of leetcode users solutions using java.
Memory: 43.94 mb, beating 61.09% of leetcode users solutions using java.

#### Concepts Applied:

Lists, HashMap, ArrayList, TreeNode, Map, Math, if-statement, and dfs. 

### Solution Oct 25, 2023 (Java, leetcode) 779. K-th Symbol in Grammar (Medium)
In .LeetcodeDailySolution folder as Oct25,2023.java

#### Prompt:

We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

#### Solution:

    class Solution {
    public int kthGrammar(int n, int k) {
        if (n == 1) {
            return 0;
        }
        
        int parent = kthGrammar(n - 1, (int) Math.ceil(k / 2.0));
        boolean isOdd = k % 2 == 1;

        if (parent == 0) {
            return isOdd ? 0 : 1;
        } else {
            return isOdd ? 1 : 0;
            }  
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.04 mb, beating 49.27% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, Math, and if-statements.

### Solution Oct 26, 2023 (Java, leetcode) 823. Binary Trees With Factors (Medium)
In .LeetcodeDailySolution folder as Oct26,2023.java

#### Prompt:

Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.

We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.

Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    private static final int MOD = 1000000007;

    public int numFactoredBinaryTrees(int[] arr) {
        Arrays.sort(arr);
        Set<Integer> s = new HashSet<>();
        for (int x : arr) s.add(x);

        Map<Integer, Integer> dp = new HashMap<>();
        for (int x : arr) dp.put(x, 1);
        
        for (int i : arr) {
            for (int j : arr) {
                if (j > Math.sqrt(i)) break;
                if (i % j == 0 && s.contains(i / j)) {
                    long temp = (long) dp.get(j) * dp.get(i / j);
                    dp.put(i, (int) ((dp.get(i) + (i / j == j ? temp : temp * 2)) % MOD));
                }
            }
        }
        
        int result = 0;
        for (int val : dp.values()) {
            result = (result + val) % MOD;
        }
        return result;
        }
    }

Runtime: 14 ms, beating 82.51% of leetcode users solutions using java.
Memory: 43.46 mb, beating 36.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Set, HashSet, for-loops, Map, HashMap, if statements, and dp.

### Solution Oct 27, 2023 (Java, leetcode) 5. Longest Palindromic String (Medium)
In .LeetcodeDailySolution folder as Oct27,2023.java

#### Prompt:

Given a string s, return the longest palindromic substring in s.

#### Solution:

    class Solution {
    public String longestPalindrome(String s) {
        StringBuilder sPrime = new StringBuilder("#");
        for (char c: s.toCharArray()) {
            sPrime.append(c).append("#");
        }
        
        int n = sPrime.length();
        int[] palindromeRadii = new int[n];
        int center = 0;
        int radius = 0;
        
        for (int i = 0; i < n; i++) {
            int mirror = 2 * center - i;
            
            if (i < radius) {
                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);
            }
            
            while (i + 1 + palindromeRadii[i] < n &&
                   i - 1 - palindromeRadii[i] >= 0 &&
                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {
                palindromeRadii[i]++;
            }
            
            if (i + palindromeRadii[i] > radius) {
                center = i;
                radius = i + palindromeRadii[i];
            }
        }
        
        int maxLength = 0;
        int centerIndex = 0;
        for (int i = 0; i < n; i++) {
            if (palindromeRadii[i] > maxLength) {
                maxLength = palindromeRadii[i];
                centerIndex = i;
            }
        }
        
        int startIndex = (centerIndex - maxLength) / 2;
        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);
        
        return longestPalindrome;
        }
    }

Runtime: 11 ms, beating 88.50% of leetcode users solutions using java.
Memory: 43.47 mb, beating 53.35% of leetcode users solutions using java.

#### Concepts Applied:

Char, charArray, for loops, if-statments, while loops, Math, charAt, strings.

### Solution Oct 28, 2023 (Java, leetcode) 1220. Count Vowels Permutation (Hard)
In .LeetcodeDailySolution folder as Oct28,2023.java

#### Prompt:

Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

#### Solution:

    class Solution {
    public int countVowelPermutation(int n) {
        final int MOD = 1000000007;

        long a = 1, e = 1, i = 1, o = 1, u = 1;

        for (int j = 1; j < n; j++) {
            long a_next = e;
            long e_next = (a + i) % MOD;
            long i_next = (a + e + o + u) % MOD;
            long o_next = (i + u) % MOD;
            long u_next = a;
            a = a_next;
            e = e_next;
            i = i_next;
            o = o_next;
            u = u_next;
            
        }
        return (int)((a + e + i + o + u) % MOD);
        }
    }

Runtime: 5 ms, beating 99.02% of leetcode users solutions using java.
Memory: 39.30 mb, beating 84.92% of leetcode users solutions using java.

#### Concepts Applied:

Long and for loop.

### Solution Oct 29, 2023 (Java, leetcode) 458. Poor Pigs (Hard)
In .LeetcodeDailySolution folder as Oct29,2023.java

#### Prompt:

There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.

You can feed the pigs according to these steps:

Choose some live pigs to feed.
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.
Wait for minutesToDie minutes. You may not feed any other pigs during this time.
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
Repeat this process until you run out of time.
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.

#### Solution:

    class Solution{
    public int poorPigs(int buckets, int tdie, int ttest){
        int test = ttest/tdie;
        int i=0;
        
        while(Math.pow(test+1,i)< buckets)
        {
            i++;
        }
        return i;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 38.70 mb, beating 95.03% of leetcode users solutions using java.

#### Concepts Applied:

Math and while loop.

### Solution Oct 30, 2023 (Java, leetcode) 1356. Sort Integers by The Number of 1 Bits (Easy)
In .LeetcodeDailySolution folder as Oct30,2023.java

#### Prompt:

You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.

Return the array after sorting it.

#### Solution:

    class Solution {
    public int[] sortByBits(int[] arr) {
        for ( int i =0 ;i< arr.length ;i++){
            arr[i] += Integer.bitCount(arr[i])*10001;
        }
        Arrays.sort(arr);
         for ( int i =0 ;i< arr.length ;i++){
             arr[i] = arr[i] %10001;
         }
        return arr;
        }
    }    

Runtime: 3 ms, beating 99.12% of leetcode users solutions using java.
Memory: 43.92 mb, beating 29.36% of leetcode users solutions using java.

#### Concepts Applied:

For loops and arrays.

### Solution Oct 31, 2023 (Java, leetcode) 2433. Find The Original Array of Prefix Xor (Medium)
In .LeetcodeDailySolution folder as Oct31,2023.java

#### Prompt:

You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:

pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
Note that ^ denotes the bitwise-xor operation.

It can be proven that the answer is unique.

#### Solution:

    class Solution {
    public int[] findArray(int[] pref) {
        int prev = pref[0];
        
        for (int i = 1; i < pref.length; i++) {
            pref[i] ^= prev;
            prev ^= pref[i];
        }
        return pref;        
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java. 
Memory: 58.68 mb, beating 54.80% of leetcode users solutions using java.

#### Concepts Applied:

findArray and for loop.

### Solution Nov 1, 2023 (Java, leetcode) 501. Find Mode in Binary Search Tree (Easy)
In .LeetcodeDailySolution folder as Nov1,2023.java

#### Prompt:

Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.

#### Solution:

    class Solution {
    private int currentVal;
    private int currentCount = 0;
    private int maxCount = 0;
    private int modeCount = 0;
    private int[] modes;
    public int[] findMode(TreeNode root) {
        inOrderTraversal(root);

        modes = new int[modeCount];
        modeCount = 0;
        currentCount = 0;

        inOrderTraversal(root);

        return modes;
    }
    private void inOrderTraversal(TreeNode node) {
        if (node == null) return;
        inOrderTraversal(node.left);
        handleValue(node.val);
        inOrderTraversal(node.right);
    }
    private void handleValue(int val) {
        if (val == currentVal) {
            currentCount++;
        } else {
            currentVal = val;
            currentCount = 1;
        }
        if (currentCount > maxCount) {
            maxCount = currentCount;
            modeCount = 1;
        } else if (currentCount == maxCount) {
            if (modes != null) {
                modes[modeCount] = currentVal;
            }
            modeCount++;
            }
        }
    }    

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.46 mb, beating 93.96% of leetcode users solutions using java.

#### Concepts Applied: 

Treenodes, traversals, if-statements, else statements, and else-if statements.

### Solution Nov 2, 2023 (Java, leetcode) 2265. Count Nodes Equal to Average of Subtree (Medium)
In .LeetcodeDailySolution folder as Nov2,2023.java

#### Prompt:

Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.

Note:

The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
A subtree of root is a tree consisting of root and all of its descendants.

#### Solution:

    class Solution {
    int count = 0;
    public int averageOfSubtree(TreeNode root) {
        dfs(root);
        return count;
    }
        private int[] dfs(TreeNode node) {
        if(node == null) {
            return new int[]{0, 0};
        } 
        int[] leftResults = dfs(node.left);
        int[] rightResults = dfs(node.right);
        
        int totalSum = node.val + leftResults[0] + rightResults[0];

        int totalCount = 1 + leftResults[1] + rightResults[1];

        if(node.val == totalSum/totalCount) count++;

        return new int[]{totalSum, totalCount};
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.40 mb, beating 95.77% of leetcode users solutions using java.

#### Concepts Applied:

dfs, Treenode, and if-statements.

### Solution Nov 4, 2023 (Java, leetcode) 1503. Last Momment Before All Ants Fall Out of a Plank (Medium)
In .LeetcodeDailySolution folder as Nov4,2023.java

#### Prompt:

We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.

When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.

Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.

#### Solution:

    class Solution {
        public int getLastMoment(int n, int[] left, int[] right) {
        int res = 0;
        for (int i: left)
            res = Math.max(res, i);
        for (int i: right)
            res = Math.max(res, n - i);
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.49 mb, beating 92.47% of leetcode users solutions using java.

#### Concepts Applied:

For loops and Math.

### Solution Nov 5, 2023 (Java, leetcode) 1535. Find the Winner of an Array Game (Medium)
In .LeetcodeDailySolution folder as Nov5,2023.java

#### Prompt:

Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.

#### Solution:

    class Solution {
    public int getWinner(int[] A, int k) {
        int cur = A[0]; int win = 0;
        
        for (int i = 1; i < A.length; ++i) {
            if (A[i] > cur) {
                cur = A[i];
                win = 0;
            }
            if (++win == k) {
                break;
            }
        }
        return cur;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 56.40 mb, beating 69.18% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loops, and if statements. 

### Solution Nov 7, 2023 (Java, leetcode) 1921. Eliminate Maximum Number of Monsters (Medium)
In .LeetcodeDailySolution folder as Nov7,2023.java

#### Prompt:

You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.

The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.

You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.

You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.

Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

#### Solution:

    class Solution {
    public int eliminateMaximum(int[] dist, int[] speed) {
        int[] time = new int[dist.length];

        for(int i=0;i<dist.length;i++)
            time[i] = (int)Math.ceil((double)dist[i]/speed[i]);

        Arrays.sort(time);

        int ans = 0;
        int T = 0;
        for(int i=0;i<time.length;i++)
        {
            if(T++<time[i])
                ans++;
            else
                break;
        }
        return ans;
        }
    }

Runtime: 19 ms, beating 62.18% of leetcode users solutions using java.
Memory: 54.50 mb, beating 83.52% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Math, for loops, and else condition. 

### Solution Nov 8, 2023 (Java, leetcode) 2849. Determine if a Cell is Reachable at a Given Time (Medium)
In .LeetcodeDailySolution folder as Nov8,2023.java

#### Prompt:

You are given four integers sx, sy, fx, fy, and a non-negative integer t.

In an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.

Return true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.

A cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.

#### Solution:

    class Solution {
    public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {
        int minsteps = 0;
        int a = Math.abs(fx - sx);
        int b = Math.abs(fy - sy);
        
        if (a == 0 && b == 0) {
            return t != 1;
        }
        if (a < b) {
            if (sy < fy) {
                return (fy - (sy + a) + a) <= t;
            } else {
                return (sy - (fy + a) + a) <= t;
            }
        } else {
            if (sx < fx) {
                return (fx - (sx + b) + b) <= t;
            } else {
                return (sx - (fx + b) + b) <= t;
                }
            }
        }
    }

Runtime: 1 ms, beating 91.04% of leetcode users solutions using java.
Memory: 39.60 mb, beating 53.57% of leetcode users solutions using java.

#### Concepts Applied:

Math, boolean, if and else statements.

### Solution Nov 9, 2023 (Java, leetcode) 1759. Count Number of Homogenous Substrings (Medium)
In .LeetcodeDailySolution folder as Nov9,2023.java

#### Prompt:

Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.

A string is homogenous if all the characters of the string are the same.

A substring is a contiguous sequence of characters within a string.

#### Solution: 

    class Solution {
    public int countHomogenous(String s) {
    var prev = '?'; var cnt = 1; var sum = 0;

    for (var c : s.toCharArray()) {
      if (c != prev) {
        cnt = 1;
        prev = c;
          }
      sum = (sum + cnt++) % 1000000007;
        }
    return sum;
      }
    }

Runtime: 6 ms, beating 95.62% of leetcode users solutions using java.
Memory: 44.08 mb, beatiing 63.58% of leetcode users solutions using java.

#### Concepts Applied:

Var, charArray, and if statement.

### Solution Nov 10, 2023 (Java, leetcode) 1743. Restore the Array From Adjacent Pairs (Medium)
In .LeetcodeDailySolution folder as Nov10,2023.java

#### Prompt:

There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.

You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.

It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.

Return the original array nums. If there are multiple solutions, return any of them.

#### Solution:

    class Solution {
    private static final int MINV = -100000, MAXV = 100000,
    RANGEV = MAXV - MINV + 1;
    private static final long UINT_MAX = 0xFFFFFFFFl;
    private static long[] index = new long[RANGEV];

    public int[] restoreArray(int[][] apairs) {
        final int n = apairs.length;
        if (n == 1) return apairs[0];
        int minv = MAXV, maxv = MINV;
        for (int i = 0; i < n; i++) {
            final var ap = apairs[i];
            final int v0 = ap[0], v1 = ap[1];
            final long j = i + 1;
            index[v0-MINV] += index[v0-MINV] == 0 ? j : j << 32;
            index[v1-MINV] += index[v1-MINV] == 0 ? j : j << 32;
            final int mn = Math.min(v0, v1);
            final int mx = Math.max(v0, v1);
            minv = Math.min(mn, minv);
            maxv = Math.max(mx, maxv);
        }

        int head = minv;
        while (head <= maxv
            && (index[head-MINV] > UINT_MAX || index[head-MINV] == 0))
            head++;

        int[] r = new int[n + 1];
        r[0] = head;
        int ri = 1;
        for (long idx = index[head-MINV]; idx != 0; idx = index[head-MINV]) {
            final int loidx = (int)(idx & UINT_MAX);
            final var ap = apairs[loidx - 1];
            index[head-MINV] >>>= 32;
            r[ri++] = head = ap[ap[0] == head ? 1 : 0];
            final int lonext = (int)(index[head-MINV] & UINT_MAX),
                      hinext = (int)(index[head-MINV] >>> 32);
            if (lonext == loidx) index[head-MINV] = hinext;
            else if (hinext == loidx) index[head-MINV] = lonext;
        }
        return r;
        }
    }

Runtime: 18 ms, beating 99.78% of leetcode users solutions using java.
Memory: 87.14 mb, beating 68.17% of leetcode users solutions using java.

#### Concepts Applied:

Long, apairs, index, Math, if statements, while and for loops.

### Solution Nov 11, 2023 (Java, leetcode) 2642. Design Graph With Shortest Path Calculator (Hard)
In .LeetcodeDailySolution folder as Nov11,2023.java

#### Prompt:

There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.

Implement the Graph class:

Graph(int n, int[][] edges) initializes the object with n nodes and the given edges.
addEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.
int shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.

#### Solution:

    class Graph {
    int[][] distance; int n;
    final int MAX_VALUE = 500_000_000;

    public Graph(int n, int[][] edges) {
        this.n = n;
        distance = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = MAX_VALUE;
            }
            distance[i][i] = 0;
        }
        for (int[] edge : edges) {
            distance[edge[0]][edge[1]] = edge[2];
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    distance[i][j] = Math.min(
                        distance[i][j],
                        distance[i][k] + distance[k][j]
                    );
                }
            }
        }
    }
    
    public void addEdge(int[] edge) {
        if (distance[edge[0]][edge[1]] <= edge[2]) {
            return;
        }
        distance[edge[0]][edge[1]] = edge[2];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = Math.min(
                    distance[i][j],
                    distance[i][edge[0]] + edge[2] + distance[edge[1]][j]
                );
            }
        }
    }
    public int shortestPath(int node1, int node2) {
        if (distance[node1][node2] == MAX_VALUE) {
            return -1;
        }
        return distance[node1][node2];
        }
    }

Runtime: 64 ms, beating 97.92% of leetcode users solutions using java.
Memory: 54.40 mb, beating 76.67% of leetcode users solutions using java.

#### Concepts Applied:

Graph, for loops, if statements, Math, and nodes.

### Solution Nov 12, 2023 (Java, leetcode) 815 Bus Routes (Hard)
In .LeetcodeDailySolution folder as Nov12,2023.java

#### Prompt:

You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.

For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.
You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.

Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.

#### Solution:

    class Solution {
    public int numBusesToDestination(int[][] routes, int source, int target) {
        if (source == target) {
            return 0;
        }
        int maxStop = -1;
        for (int[] route : routes) {
            for (int stop : route) {
                maxStop = Math.max(maxStop, stop);
            }
        }
        if (maxStop < target) {
            return -1;
        }
        int n = routes.length;
        int[] minBusesToReach = new int[maxStop + 1];
        Arrays.fill(minBusesToReach, n + 1);
        minBusesToReach[source] = 0;
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int[] route : routes) {
                int min = n + 1;
                for (int stop : route) {
                    min = Math.min(min, minBusesToReach[stop]);
                }
                min++;
                for (int stop : route) {
                    if (minBusesToReach[stop] > min) {
                        minBusesToReach[stop] = min;
                        flag = true;
                    }
                }
            }
            
        }
        return (minBusesToReach[target] < n + 1 ? minBusesToReach[target] : -1);
        }
    }

Runtime: 4 ms, beating 82.66% of leetcode users solutions using java.
Memory: 53.89 mb, beating 97.41% of leetcode users solutions using java.

#### Concepts Applied:

For loops, Math, Arrays, boolean, while loop, and if statements.

### Solution Nov 13, 2023 (Java, leetcode) 2785. Sort Vowels in a String (Medium)
In .LeetcodeDailySolution folder as Nov13,2023.java

#### Prompt:

Given a 0-indexed string s, permute s to get a new string t such that:

All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].
The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].
Return the resulting string.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.

#### Solution:

    class Solution {
    boolean isVowel(Character c) {
        return c == 'a' || c == 'e' || c == 'o'|| c == 'u'|| c == 'i'
                || c == 'A' || c == 'E' || c == 'O'|| c == 'U'|| c == 'I';
    }
    public String sortVowels(String s) {
        int[] count = new int[1000];
        for (char c : s.toCharArray()) {
            if (isVowel(c)) {
                count[c - 'A']++;
            }
        }
        String sortedVowel = "AEIOUaeiou";
        StringBuilder ans = new StringBuilder();
        int j = 0;
        for (int i = 0; i < s.length(); i++) {
            if (!isVowel(s.charAt(i))) {
                ans.append(s.charAt(i));
            } else {
                while (count[sortedVowel.charAt(j) - 'A'] == 0) {
                    j++;
                }
                ans.append(sortedVowel.charAt(j));
                count[sortedVowel.charAt(j) - 'A']--;
            }
        }
        return ans.toString();
        }
    }

Runtime: 21 ms, beating 82.90% of leetcode users solutions using java.
Memory: 44.37 mb, beating 91.33% of leetcode users solutions using java.

#### Concepts Applied:

Booleans, chars, charArr, strings, for loops, charAt, if statements, else statements, and while loop.

### Solution Nov 14, 2023 (Java, leetcode) 1930. Unique Length-3 Palindromic Subsequences (Medium)
In .LeetcodeDailySolution folder as Nov14,2023.java

#### Prompt:

Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".

#### Solution:

    class Solution {
    public int countPalindromicSubsequence(String inputString) {
        int[] minExist = new int[26];
        int[] maxExist = new int[26];
        for (int i = 0; i < 26; i++) {
            minExist[i] = Integer.MAX_VALUE;
            maxExist[i] = Integer.MIN_VALUE;
        }
        for (int i = 0; i < inputString.length(); i++) {
            int charIndex = inputString.charAt(i) - 'a';
            minExist[charIndex] = Math.min(minExist[charIndex], i);
            maxExist[charIndex] = Math.max(maxExist[charIndex], i);
        }
        int uniqueCount = 0;
        for (int charIndex = 0; charIndex < 26; charIndex++) {
            if (minExist[charIndex] == Integer.MAX_VALUE || maxExist[charIndex] == Integer.MIN_VALUE) {
                continue; 
            }
            HashSet<Character> uniqueCharsBetween = new HashSet<>();
            for (int j = minExist[charIndex] + 1; j < maxExist[charIndex]; j++) {
                uniqueCharsBetween.add(inputString.charAt(j));
            }
            uniqueCount += uniqueCharsBetween.size();
        }
        return uniqueCount;
        }
    }

Runtime: 155 ms, beating 75.16% of leetcode users solutions using java.
Memory: 44.29 mb, beating 71.41% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loops, charIndex, charAt, Math, and HashSet.

### Solution Nov 15, 2023 (Java, leetcode) 1846. Maximum Element After Decreasing and Rearranging (Medium)
In .LeetcodeDailySolution folder as Nov15,2023.java

#### Prompt:

You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:

The value of the first element in arr must be 1.
The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
There are 2 types of operations that you can perform any number of times:

Decrease the value of any element of arr to a smaller positive integer.
Rearrange the elements of arr to be in any order.
Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.

#### Solution:

    class Solution {
    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {
        Arrays.sort(arr);
        arr[0] = 1;

        for (int i = 1; i < arr.length; ++i) {
            if (Math.abs(arr[i] - arr[i - 1]) <= 1) {
                continue; 
            } else {
                arr[i] = arr[i - 1] + 1; 
            }
        }
        return arr[arr.length - 1]; 
        }
    }

Runtime: 6 ms, beating 62.75% of leetcode users solutions using java.
Memory: 56.68 mb, beating 48.40% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, Math, if and else statements.

### Solution Nov 16, 2023 (Java, leetcode) 1980. Find Unique Binary String (Medium)
In .LeetcodeDailySolution folder as Nov16,2023.java

#### Prompt:

Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. 
If there are multiple answers, you may return any of them.

#### Solution:

    class Solution {
    public String findDifferentBinaryString(String[] nums) {
        StringBuilder sb = new StringBuilder();

        for(int i=0;i<nums.length;i++)
        {
            sb.append(nums[i].charAt(i) == '0'? "1": "0");
        }
        return new String(sb);
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.43 mb, beating 73.89% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loop, and charAt.

### Solution Nov 17, 2023 (Java, leetcode) 1877. Minimize Maximum Pair Sum in Array (Medium)
In .LeetcodeDailySolution folder as Nov17,2023.java

#### Prompt:

The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.

For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:

Each element of nums is in exactly one pair, and
The maximum pair sum is minimized.
Return the minimized maximum pair sum after optimally pairing up the elements.

#### Solution: 

    class Solution {
    public int minPairSum(int[] nums) {
        Arrays.sort(nums);
        int left = 0, right = nums.length - 1;
        int minMaxPairSum = Integer.MIN_VALUE;

        while (left < right) {
            int currentPairSum = nums[left] + nums[right];
            minMaxPairSum = Math.max(minMaxPairSum, currentPairSum);
            left++;
            right--;
        }
        return minMaxPairSum;
        }
    }

Runtime: 53 ms, beating 86.60% of leetcode users solutions using java.
Memory: 56.48 mb, beating 96.69% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, while loop, and Math.

### Solution Nov 18, 2023 (Java, leetcode) 1838. Frequency of the Most Frequent Element (Medium)
In .LeetcodeDailySolution folder as Nov18,2023.java

#### Prompt:

The frequency of an element is the number of times it occurs in an array.

You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.

Return the maximum possible frequency of an element after performing at most k operations.

#### Solution:

    class Solution {
    public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        int i = 0;
        int j = 0;
        int sum = 0;
        int maxLength = 0;

        for (i = 0; i < nums.length; i++) {
            sum += nums[i];
            while ((i - j + 1) * nums[i] - sum > k) {
                sum -= nums[j];
                j++;
            }
            maxLength = Math.max(maxLength, i - j + 1);
        }
        return maxLength;
        }
    }

Runtime: 29 ms, beating 77.42% of leetcode users solutions using java.
Memory: 56.53 mb, beating 83.11% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, while loop, and Math.

### Solution Nov 19, 2023 (Java, leetcode) 1887. Reduction Operations to Make the Array Element Equal (Medium)
In .LeetcodeDailySolution folder as Nov19,2023.java

#### Prompt:

Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

#### Solution:

    class Solution {
    public int reductionOperations(int[] nums) {
        int n = nums.length;
        int[] freq = new int[50001];

        for (int i = 0; i < n; i++) {
            freq[nums[i]]++;
        }
        int res = 0, operations = 0;

        for (int i = 50000; i >= 1; i--) {

            if (freq[i] > 0) {

                operations += freq[i];

                res += operations - freq[i];
            }
        }
        return res;
        }
    }

Runtime: 7 ms, beating 99.25% of leetcode users solutions using java.
Memory: 53.99 mb, beating 98.99% of leetcode users solutions using java.

#### Concepts Applied:

Array, for loop, and if statements.

### Solution Nov 20, 2023 (Java, leetcode) 2391. Minimum Amount of Time to Collect Garbage (Medium)
In .LeetcodeDailySolution folder as Nov20,2023.java

#### Prompt:

You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.

You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.

There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.

Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.

Return the minimum number of minutes needed to pick up all the garbage.

#### Solution:

    class Solution {
    boolean hasG = false, hasP = false, hasM = false;
    public int garbageCollection(String[] garbage, int[] travel) {
        int n = garbage.length;
        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            ans += 3 * travel[i];
        }
        for (String s : garbage) {
            ans += s.length();
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("G")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("P")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("M")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        return ans;
        }
    }

Runtime: 2 ms, beating 99.33% of leetcode users solutions using java.
Memory: 60.74 mb, beating 88.61% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, for loops, and strings.

### Solution Nov 21, 2023 (Java, leetcode) 1814. Count Nice Pairs in an Array (Medium)
In .LeetcodeDailySolution folder as Nov21,2023.java

#### Prompt:

You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:

0 <= i < j < nums.length
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int countNicePairs(int[] nums) {
        final int mod = 1000000007;
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            nums[i] = nums[i] - reverse(nums[i]);
        }
        Arrays.sort(nums);
        long res = 0;
        for (int i = 0; i < len - 1; i++) {
            long count = 1;
            while (i < len - 1 && nums[i] == nums[i + 1]) {
                count++;
                i++;
            }
            res = (res % mod + (count * (count - 1)) / 2) % mod;
        }

        return (int) (res % mod);
    }
    private int reverse(int num) {
        int rev = 0;
        while (num > 0) {
            rev = rev * 10 + num % 10;
            num /= 10;
        }
        return rev;
        }
    }

Runtime: 20 ms, beating 100% of leetcode users solutions using java.
Memory: 54.70 mb, beating 63.24% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, long, for loops, and while loops.

### Solution Nov 22, 2023 (Java, leetcode) 1424. Diagonal Traverse II (Medium)
In .LeetcodeDailySolution folder as Nov22,2023.java

#### Prompt:

Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.

#### Solution:

    class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        Queue<Pair<Integer, Integer>> queue = new LinkedList();
        queue.offer(new Pair(0, 0));
        List<Integer> ans = new ArrayList();
        
        while (!queue.isEmpty()) {
            Pair<Integer, Integer> p = queue.poll();
            int row = p.getKey();
            int col = p.getValue();
            ans.add(nums.get(row).get(col));
            
            if (col == 0 && row + 1 < nums.size()) {
                queue.offer(new Pair(row + 1, col));
            }
            if (col + 1 < nums.get(row).size()) {
                queue.offer(new Pair(row, col + 1));
            }
        }
        int[] result = new int[ans.size()];
        int i = 0;
        for (int num : ans) {
            result[i] = num;
            i++;
        }
        return result;
        }
    }

Runtime: 28 ms, beating 72% of leetcode users solutions using java.
Memory: 68.89 mb, beating 63.64% of leetcode users solutions using java.

#### Concepts Applied:

List, linkedlist, queue, and Arraylist.

### Solution Nov 23, 2023 (Java, leetcode) 1630. Arithmetic Subarrays (Medium)
In .LeetcodeDailySolution folder as Nov23,2023.java

#### Prompt:

A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:

1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.

Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.

#### Solution:

    class Solution {
    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {
        List<Boolean> res=new ArrayList<>();
        
        for(int i=0;i<l.length;i++){
            if(r[i]-l[i]<2) res.add(true);
            else{
                int minNum=minNum(nums,l[i],r[i]);
                int maxNum=maxNum(nums,l[i],r[i]);
                int diff=maxNum-minNum;
                int countDiff=r[i]-l[i];
                if(minNum==maxNum) res.add(true);
                else if(diff%countDiff!=0) res.add(false);
                else{
                    int d=diff/countDiff;
                    boolean[] mark=new boolean[r[i]-l[i]+1];
                    boolean flag=true;
                    for(int p=l[i];p<=r[i];p++){
                        if((nums[p]-minNum)%d!=0) {
                            flag=false;
                            break;
                        }
                        if(mark[(nums[p]-minNum)/d]){
                            flag=false;
                            break;
                        }
                        else {
                            mark[(nums[p]-minNum)/d]=true;
                        }

                    }
                    res.add(flag);
                }
                }
        }
        System.gc();
        return res;
    }  
        public int minNum(int[] nums,int left,int right){
            int ans=nums[left];
            for(int i=left;i<=right;i++){
                ans=Math.min(ans,nums[i]);
            }
            return ans;
        }
        public int maxNum(int[] nums,int left,int right){
            int ans=nums[left];
            for(int i=left;i<=right;i++){
                ans=Math.max(ans,nums[i]);
            }
            return ans;
        }
    }

Runtime: 10 ms, beating 97.52% of leetcode users solutions using java.
Memory: 42.34 mb, beating 99.72% of leetcode users solutions using java.

#### Concepts Applied:

Lists, booleans, ArrayLists, for loops, if statements, else statements, and Math.

### Solution Nov 24, 2023 (Java, leetcode) 1561. Maximum Number of Coins You Can Get (Medium)
In .LeetcodeDailySolution folder as Nov24,2023.java

#### Prompt:

There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with the maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.

Return the maximum number of coins that you can have.

#### Solution:

    class Solution {
    public int maxCoins(int[] piles) {
        int ans = 0; int n = piles.length;
        Arrays.sort(piles);

        for (int i = n / 3; i < n; i += 2) {
            ans += piles[i];
        }
        return ans;
        }
    }

Runtime: 27 ms, beating 98.94% leetcode users solutions using java.
Memory: 54.45 mb, beating 72.08% leetcode users solutions using java.

#### Concepts Applied:

Arrays and for loop.

### Solution Nov 25, 2023 (Java, leetcode) 1685. Sum of Absolute Differences in a Sorted Array (Medium)
In .LeetcodeDailySolution folder as Nov25,2023.java

#### Prompt:

You are given an integer array nums sorted in non-decreasing order.

Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.

In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).

#### Solution:

    class Solution {
    public int[] getSumAbsoluteDifferences(int[] nums) {
        int n = nums.length;
        int[] prefix = new int[n];

        prefix[0] = nums[0];

        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }
        
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int leftSum = prefix[i] - nums[i];
            int rightSum = prefix[n - 1] - prefix[i];
            
            int leftCount = i;
            int rightCount = n - 1 - i;
            
            int leftTotal = leftCount * nums[i] - leftSum;
            int rightTotal = rightSum - rightCount * nums[i];
            
            ans[i] = leftTotal + rightTotal;
        }
        return ans;
        }
    }

Runtime: 4 ms, beating 62.31% of leetcode users solutions using java.
Memory: 57.61 mb, beating 68.89% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loops, and prefix sums.

### Solution Nov 26, 2023 (Java, leetcode) 1727. Largest Submatrix With Rearrangements (Medium)
In .LeetcodeDailySolution folder as Nov26,2023.java

#### Prompt:

You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.

Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.

#### Solution:

    class Solution {
    public int largestSubmatrix(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;

        for (int i = 1; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 1) {
                    matrix[i][j] += matrix[i - 1][j];
                }
            }
        }

        int res = 0;
        for (int i = 0; i < row; i++) {
            Arrays.sort(matrix[i]);

            for (int j = 0; j < col; j++) {
                int height = matrix[i][j];
                int width = col - j;
                res = Math.max(res, height * width);
            }
        }

        return res;        
        }
    }

Runtime: 8 ms, beating 100% of leetcode users solutions using java.
Memory: 67.44 mb, beating 56.32% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, for loops, and Math.

### Solution Nov 27, 2023 (Java, leetcode) 935. Knight Dealer (Medium)
In .LeetcodeDailySolution folder as Nov27,2023.java

#### Prompt:

The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:

A chess knight can move as indicated in the chess diagram below:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/9f5adc8f-5fb5-4f5b-a3bb-bd91026b6958)

We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/9f358451-bcd4-481a-aefe-0b60f9d69667)

Given an integer n, return how many distinct phone numbers of length n we can dial.

You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.

As the answer may be very large, return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    static final int MOD = 1_000_000_007;
    public int knightDialer(int n) {
        long[] curPos = new long[10];

        Arrays.fill(curPos, 1);

        for (int jump = 2; jump <= n; jump++) {
            long[] newPos = new long[10];

            newPos[0] = (curPos[6] + curPos[4]) % MOD;
            newPos[1] = (curPos[6] + curPos[8]) % MOD;
            newPos[2] = (curPos[7] + curPos[9]) % MOD;
            newPos[3] = (curPos[4] + curPos[8]) % MOD;
            newPos[4] = (curPos[0] + curPos[3] + curPos[9]) % MOD;
            newPos[5] = 0;  
            newPos[6] = (curPos[0] + curPos[1] + curPos[7]) % MOD;
            newPos[7] = (curPos[2] + curPos[6]) % MOD;
            newPos[8] = (curPos[1] + curPos[3]) % MOD;
            newPos[9] = (curPos[2] + curPos[4]) % MOD;

            curPos = newPos;
        }
        long totalCount = 0;
        for (int i = 0; i < 10; i++) {
            totalCount = (totalCount + curPos[i]) % MOD;
        }
        return (int) totalCount;
        }
    }

Runtime: 20 ms, beating 83.37% of leetcode users solutions using java.
Memory: 43.23 mb, beating 69.42% of leetcode users solutions using java.

#### Concepts Applied:

Long, arrays, pos, and for loop.

### Solution Nov 28, 2023 (Java, leetcode) 2147. Number of Ways to Divide a Long Corrdior (Hard)
In .LeetcodeDailySolution folder as Nov28,2023.jaca

#### Prompt:

Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.

One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.

Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.

Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.

#### Solution:

    class Solution {
    public int numberOfWays(String corridor) {
        int x = 1;
        int y = 0; 
        int z = 0;
        int mod = (int)1e9 + 7;
        
        for (int i = 0; i < corridor.length(); ++i)
            if (corridor.charAt(i) == 'S') {
                x = (x + z) % mod;
                z = y; 
                y = x;
                x = 0;
            } else {
                x = (x + z) % mod;
            }
        return z;
        }
    }

Runtime: 21 ms, beating 97.30% of leetcode users solutions using java.
Memory: 44.83 mb, beating 70.27% of leetcode users solutions using java.

#### Concepts Applied:

charAt, strings, for loop, if statement, and else statement.

### Solution Nov 29, 2023 (Java, leetcode) 191. Number of 1 Bits (Easy)
In .LeetcodeDailySolution folder as Nov29,2023.java

#### Prompt:

Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

Note:

Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.

#### Solution:

    class Solution {
    public int hammingWeight(int n) {
        int count = 0;

        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
      }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.80 mb, beating 6.93% of leetcode users solutions using java.

#### Concepts Applied:

While loop, and Brian Kernighan's Algorithm.

### Solution Nov 30, 2023 (Java, leetcode) 1611. Minimum One Bit Operations to Make Integers Zero (Hard) 
In .LeetcodeDailySolution folder as Nov30,2023.java

#### Prompt:

Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

#### Solution:

    class Solution {
        public int minimumOneBitOperations(int n) {
        int sign = 1, res = 0;

        while (n > 0) {
            res += n ^ (n - 1) * sign;
            n &= n - 1;
            sign = -sign;
        }
        return Math.abs(res);
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.27 mb, beating 56.86% of leetcode users solutions using java.

#### Concepts Applied:

Math, recursion, and while loop.

### Solution Dec 1, 2023 (Java, leetcode) 1662. Check If Two String Arrays are Equivalent (Easy)
In .LeetcodeDailySolution folder as Dec1,2023.java

#### Prompt:

Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

#### Solution:

    class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {

        StringBuilder sb1 = new StringBuilder();

        for ( String str : word1 ) sb1.append(str);
        StringBuilder sb2 = new StringBuilder();

        for ( String str : word2 ) sb2.append(str);
        
        return (sb1.toString().equals(sb2.toString()));
        
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.35 mb, beating 55.19% of leetcode users solutions using java.

#### Concepts Applied:

Strings, stringbuilder, boolean, and for loop.

### Solution Dec 2, 2023 (Java, leetcode) 1160. Find Words That Can Be Formed by Characters (Easy)
In .LeetcodeDailySolution folder as Dec2,2023.java

#### Prompt:

You are given an array of strings words and a string chars.

A string is good if it can be formed by characters from chars (each character can only be used once).

Return the sum of lengths of all good strings in words.

#### Solution:

    class Solution {
    public int countCharacters(String[] words, String chars) {
        int[] counts = new int[26];

        for(int i=0;i<chars.length();i++){
            counts[chars.charAt(i)-'a']++;
        }
        
        int res =0 ;

        for(String s : words)
        {
            if(canForm(s,counts))
                res+=s.length();
        }
        return res;
    }

    boolean canForm(String word, int[] counts){
        int[] c = new int[26];

        for(int i =0;i<word.length();i++)
        {
            int x = word.charAt(i)-'a';
            c[x]++;
            if(c[x] > counts[x])
                return false;
        }
        return true;
        }
    }

Runtime: 2 ms, beating 100% of leetcode users solutions using java.
Memory: 44.00 mb, beating 79.77% of leetcode users solutions using java.

#### Concepts Applied:

Strings, chars, charAt, for loops, and boolean.

### Solution Dec 3, 2023 (Java, leetcode) 1266. Minimum Time Visiting All Points (Easy)
In .LeetcodeDailySolution folder as Dec3,2023.java

#### Prompt:

On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.

You can move according to these rules:

In 1 second, you can either:
move vertically by one unit,
move horizontally by one unit, or
move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
You have to visit the points in the same order as they appear in the array.
You are allowed to pass through points that appear later in the order, but these do not count as visits.

#### Solution:

    class Solution {
    public int toTime(int[] from, int[] to) {
        int xDiff = Math.abs(from[0] - to[0]);
        int yDiff = Math.abs(from[1] - to[1]);
        
        return Math.max(xDiff, yDiff);
    }
    
    public int minTimeToVisitAllPoints(int[][] points) {
        int time = 0;
    
        for (int i = 1; i < points.length; i++) {
            time += toTime(points[i - 1], points[i]);
        }
        return time;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.16 mb, beating 60.89% of leetcode users solutions using java.

#### Concepts Applied:

Math, and for loop.

### Solution Dec 4, 2023 (Java, leetcode) 2264. Largest 3-Same-Digit Number in String (Easy)
In .LeetcodeDailySolution folder as Dec4,2023.java

#### Prompt:

You are given a string num representing a large integer. An integer is good if it meets the following conditions:

It is a substring of num with length 3.
It consists of only one unique digit.
Return the maximum good integer as a string or an empty string "" if no such integer exists.

Note:

A substring is a contiguous sequence of characters within a string.
There may be leading zeroes in num or a good integer.

#### Solution:

    class Solution {
    public String largestGoodInteger(String num) {
        char maxDigit = '\0';

        for (int index = 0; index <= num.length() - 3; ++index) {
            if (num.charAt(index) == num.charAt(index + 1) && num.charAt(index) == num.charAt(index + 2)) {
                maxDigit = (char) Math.max(maxDigit, num.charAt(index));
            }
        }

        return maxDigit == '\0' ? "" : new String(new char[]{maxDigit, maxDigit, maxDigit});
        }
    }

Runtime: 2 ms, beating 80.42% of leetcode users solutions using java.
Memory: 40.70 mb, beating 82.25% of leetcode users solutions using java.

#### Concepts Applied:

Char, charAt, for loop, index, and if statement.

### Solution Dec 5, 2023 (Java, leetcode) 1688. Count of Matches in Tournament (Easy)
In .LeetcodeDailySolution folder as Dec5,2023.java

#### Prompt:

You are given an integer n, the number of teams in a tournament that has strange rules:

If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.

#### Solution:

    class Solution {
    public int numberOfMatches(int n) {
        
        return n - 1;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.16 mb, beating 61.47% of leetcode users solutions using java.

#### Concepts Applied:

If after each match one team needs to be eliminated, n-1 satisfies all conditions. 

### Solution Dec 6, 2023 (Java, leetcode) 1716. Calculate Money in Leetcode Bank (Easy)
In .LeetcodeDailySolution folder as Dec6,2023.java

#### Prompt:

Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.

He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.
Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

#### Solution:

    class Solution {
    public int totalMoney(int n) {
        int total = 0;

        for (int day = 0; day < n; day++) {
            total += (day / 7 + 1) + (day % 7);
        }

        return total;        
        }
    }

Runtime: 1 ms, beating 60.52% of leetcode users solutions using java.
Memory: 39.10 mb, beating 67.38% of leetcode users solutions using java.

#### Concepts Applied:

For loop and simple calculations.

### Solution Dec 7, 2023 (Java, leetcode) 1903. Largest Odd Number in String (Easy)
In .LeetcodeDailySolution folder as Dec7,2023.java

#### Prompt:

You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public String largestOddNumber(String num) {

        for(int i=num.length()-1; i>=0; i--){
            if((num.charAt(i)-'0')%2==1)  
            return num.substring(0,i+1);
        }
        return "";
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 44.19 mb, beating 94% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loop, if statement, charAt, and substring.

### Solution Dec 8, 2023 (Java, leetcode) 606. Construct String from Binary Tree (Easy)
In .LeetcodeDailySolution folder as Dec8,2023.java

#### Prompt:

Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.

Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

#### Solution:

    class Solution {
    public String tree2str(TreeNode t) {
        StringBuilder res = new StringBuilder();
        dfs(t, res);
        return res.toString();
    }
    public static void dfs(TreeNode t, StringBuilder res) {
        if (t == null)
            return;

        res.append(String.valueOf(t.val));
        if (t.left == null && t.right == null)
            return;

        res.append('(');
        dfs(t.left, res);
        res.append(')');
        
        if (t.right != null) {
            res.append('(');
            dfs(t.right, res);
            res.append(')');
            }
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 43.30 mb, beating 86.73% of leetcode users solutions using java.

#### Concepts Applied:

StringBuilder, strings, dfs, and if statements.

### Solution Dec 9, 2023 (Java, leetcode) 94. Binary Tree Inorder Traversal (Easy)
In .LeetcodeDailySolution folder as Dec9,2023.java

#### Prompt:

Given the root of a binary tree, return the inorder traversal of its nodes' values.

#### Solution:

    class Solution {
    List<Integer> ans = new ArrayList<>();
        public List<Integer> inorderTraversal(TreeNode root) {

        if (root == null) return Collections.emptyList();

        inorderTraversal(root.left);
        ans.add(root.val);
        inorderTraversal(root.right);

        return ans;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.30 mb, beating 92.99% of leetcode users solutions using java.

#### Concepts Applied:

Lists, ArrayList, inorderTraversal, and TreeNode.

### Solution Dec 10, 2023 (Java, leetcode) 867. Transpose Matrix (Easy)
In .LeetcodeDailySolution folder as Dec10,2023.java

#### Prompt:

Given a 2D integer array matrix, return the transpose of matrix.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/05c43a56-2bf7-4781-95a2-c061ad8608cd)

#### Solution:

    class Solution {
    public int[][] transpose(int[][] matrix) {
        int row=matrix.length;
        int col=matrix[0].length;
        int arr[][]=new int[col][row];
    
        for(int i=0;i<col;i++){
            for(int j=0;j<row;j++){
            arr[i][j]=matrix[j][i];
            }
        }
        return arr;
        }
    }   

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.88 mb, beating 97.49% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, arr, and for loop. 

### Solution Dec 11, 2023 (Java, leetcode) 1287. Element Appearing More Than 25% In Sorted Array (Easy)
In .LeetcodeDailySolution folder as Dec11,2023.java

#### Prompt:

Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

#### Solution:

    class Solution {
    public int findSpecialInteger(int[] arr) {
        int size = arr.length;
        int qtr = size / 4;
        int cnt = 1;
        int p = arr[0];

        for (int i = 1 ; i < arr.length ; i++) {
            if ( p == arr[i]) cnt++;
            else cnt = 1;
            if (cnt > qtr) return arr[i];
            p = arr[i];
        }
        return p;
        }
    }

Runtime: 1 ms, beating 64.27% of leetcode users solutions using java.
Memory: 43.13 mb, beating 72.62% of leetcode users solutions using java.

#### Concepts Applied:

arr, for loop, else statement, and if statement.

### Solution Dec 12, 2023 (Java, leetcode) 1464. Maximum Product of Two Elements in an Array (Easy)
In .LeetcodeDailySolution folder as Dec12,2023.java

#### Prompt:

Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).

#### Solution:

    class Solution {
    public int maxProduct(int[] nums) {
        int firstMax = 0;
        int secondMax = 0;

        for (int num : nums) {
            if (num > firstMax) {
                secondMax = firstMax;
                firstMax = num;
            } else {
                secondMax = Math.max(secondMax, num);
            }
        }
        return (firstMax - 1) * (secondMax - 1);        
        }
    }

Runtime: 1 ms, beating 78.60% of leetcode users solutions using java.
Memory: 41.46 mb, beating 71.33% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statement, else statement, and Math.

### Solution Dec 13, 2023 (Java, leetcode) 1582. Special Positions in a Binary Matrix (Easy)
In .LeetcodeDailySolution folder as Dec13,2023.java

#### Prompt:

Given an m x n binary matrix mat, return the number of special positions in mat.

A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).

#### Solution:

    class Solution {
    public int numSpecial(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int[] rowCount = new int[m];
        int[] colCount = new int[n];
        
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                if (mat[row][col] == 1) {
                    rowCount[row]++;
                    colCount[col]++;
                }
            }
        }
        int ans = 0;
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                if (mat[row][col] == 1) {
                    if (rowCount[row] == 1 && colCount[col] == 1) {
                        ans++;
                    }
                }
            }
        }
        return ans;
        }
    }

Runtime: 2 ms, beating 89.24% of leetcode users solutions using java.
Memory: 43.70 mb, beating 75.07% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, for loops, and if statements.

### Solution Dec 14, 2023 (Java, leetcode) 2482. Difference Between Ones and Zeros in Row and Column (Medium)
In .LeetcodeDailySolution folder as Dec14,2023.java

#### Prompt:

You are given a 0-indexed m x n binary matrix grid.

A 0-indexed m x n difference matrix diff is created with the following procedure:

Let the number of ones in the ith row be onesRowi.
Let the number of ones in the jth column be onesColj.
Let the number of zeros in the ith row be zerosRowi.
Let the number of zeros in the jth column be zerosColj.
diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
Return the difference matrix diff.

#### Solution:

    class Solution {
    public int[][] onesMinusZeros(int[][] grid) {
        int row = grid.length; 
        int col = grid[0].length;
        int[][] diff = new int[row][col];
        int[] r = new int[row]; 
        int[] c = new int[col]; 

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                r[i] += grid[i][j]; 
                c[j] += grid[i][j];
            }
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                diff[i][j] = 2 * (r[i] + c[j]) - row - col;
            }
        }
        return diff; 
        }
    }

Runtime: 9 ms, beating 70.09% of leetcode users solutions using java.
Memory: 71.60 mb, beating 64.84% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, grid, and for loops.

### Solution Dec 15, 2023 (Java, leetcode) 1436. Destination City (Easy)
In .LeetcodeDailySolution folder as Dec15,2023.java

#### Prompt:

You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.

It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

#### Solution:

    class Solution {
    public String destCity(List<List<String>> paths) {
        Set<String> cities = new HashSet<>(); 
        for (List<String> path : paths) {
            cities.add(path.get(0)); 
        }
        
        for (List<String> path : paths) {
            String dest = path.get(1); 
            if (!cities.contains(dest)) {
                return dest; 
            }
        }
        return "";
        }
    }

Runtime: 2 ms, beating 79.16% of leetcode users solutions using java.
Memory: 42.93 mb, beating 60.20% of leetcode users solutions using java.

#### Concepts Applied:

List, Set, HashSet, for loops, and if statement.

### Solution Dec 16, 2023 (Java, leetcode) 241. Valid Anagram (Easy)
In .LeetcodeDailySolution folder Dec16,2023.java

#### Prompt:

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

#### Solution:

    class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count = new int[26];

        if (s.length() != t.length()) {
            return false;
        }
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a'] += 1;
        }
        for (int i = 0; i < t.length(); i++) {
            if (count[t.charAt(i) - 'a'] == 0) {
                return false;
            }
            count[t.charAt(i) - 'a'] -= 1;
        }
        return true;        
        }
    }

Runtime: 4 ms, beating 73.09% of leetcode users solutions using java.
Memory: 42.18 mb, beating 78.86% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, strings, if statements, for loops, and charAt.

### Solution Dec 17, 2023 (Java, leetcode) 2353. Design a Food Rating System (Medium)
In .LeetcodeDailySolution folder as Dec17,2023.java

#### Prompt:

Design a food rating system that can do the following:

Modify the rating of a food item listed in the system.
Return the highest-rated food item for a type of cuisine in the system.
Implement the FoodRatings class:

FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
foods[i] is the name of the ith food,
cuisines[i] is the type of cuisine of the ith food, and
ratings[i] is the initial rating of the ith food.
void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.
Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

#### Solution:

    class Food implements Comparable<Food> {
    public int foodRating;
    public String foodName;
    public Food(int foodRating, String foodName) {
        this.foodRating = foodRating;
        this.foodName = foodName;
    }
    @Override
    public int compareTo(Food other) {
        if (foodRating == other.foodRating) {
            return foodName.compareTo(other.foodName);
        }
        return -1 * Integer.compare(foodRating, other.foodRating);
        }
    }
    class FoodRatings {
    private Map<String, Integer> foodRatingMap;
    private Map<String, String> foodCuisineMap;
    private Map<String, PriorityQueue<Food>> cuisineFoodMap;

    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        foodRatingMap = new HashMap<>();
        foodCuisineMap = new HashMap<>();
        cuisineFoodMap = new HashMap<>();

        for (int i = 0; i < foods.length; ++i) {

            foodRatingMap.put(foods[i], ratings[i]);
            foodCuisineMap.put(foods[i], cuisines[i]);
            cuisineFoodMap.computeIfAbsent(cuisines[i], k -> new PriorityQueue<>()).add(new Food(ratings[i] , foods[i]));
        }
    } 
    public void changeRating(String food, int newRating) {
        foodRatingMap.put(food, newRating);
        String cuisineName = foodCuisineMap.get(food);
        cuisineFoodMap.get(cuisineName).add(new Food(newRating, food));
    }
    public String highestRated(String cuisine) {
        Food highestRated = cuisineFoodMap.get(cuisine).peek();

        while (foodRatingMap.get(highestRated.foodName) != highestRated.foodRating) {
            cuisineFoodMap.get(cuisine).poll();
            highestRated = cuisineFoodMap.get(cuisine).peek();
        }        
        return highestRated.foodName;
        }
    }

Runtime: 157 ms, beating 93.68% of leetcode users solutions using java.
Memory: 68.66 mb, beating 95.40% of leetcode users solutions using java.

#### Concepts Applied:

Maps, overriding, strings, HashMaps, if statement, for loops, and while loop.

### Solution Dec 18, 2023 (Java, leetcode) 1913. Maximum Product Difference Between Two Pairs (Easy)
In .LeetcodeDailySolution folder as Dec18,2023.java

#### Prompt:

The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

#### Solution:

    class Solution {
    public int maxProductDifference(int[] nums) {
        int firstBig = 0, secondBig = 0;
        int firstSmall = Integer.MAX_VALUE, secondSmall = Integer.MAX_VALUE;

        for (int n : nums) {
            if (n < firstSmall) {
                secondSmall = firstSmall;
                firstSmall = n;
            } else if (n < secondSmall) {
                secondSmall = n;
            }
            if (n > firstBig) {
                secondBig = firstBig;
                firstBig = n;
            } else if (n > secondBig) {
                secondBig = n;
            }
        }
        return firstBig * secondBig - firstSmall * secondSmall;        
        }
    }

Runtime: 2 ms, beating 97.52% of leetcode users solutions using java.
Memory: 44.11 mb, beating 55.36% of leetcode users solutions using java.

#### Concepts Applied:

For loops, if statements, else-if statements, and integer pairs.

### Solution Dec 19, 2023 (Java, leetcode) 661. Image Smoother 
In .LeetcodeDailySolution folder as Dec19,2023.java

#### Prompt:

An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/80c006ea-91de-46dc-abc7-2d79623dd15f)

Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.

#### Solution:

    class Solution {
    public int[][] imageSmoother(int[][] img) {
        int rows = img.length;
        int cols = img[0].length;
        int[][] result = new int[rows][cols];

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                int totalSum = 0;
                int count = 0;

                for (int x = Math.max(0, i-1); x < Math.min(rows, i+2); ++x) {
                    for (int y = Math.max(0, j-1); y < Math.min(cols, j+2); ++y) {
                        totalSum += img[x][y];
                        count += 1;
                    }
                }
                result[i][j] = totalSum / count;
            }
        }
        return result;
        }
    }

Runtime: 6 ms, beating 80% of leetcode users solutions using java.
Memory: 44.46 mb, beating 71.94% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, rows, cols, for loops, and Math.

### Solution Dec 20, 2023 (Java, leetcode) 2706. Buy Two Chocolates (Easy)
In .LeetcodeDailySolution folder as Dec20,2023.java

#### Prompt:

You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.

You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.

Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.

#### Solution:

    class Solution {
    public int buyChoco(int[] prices, int money) {
        Arrays.sort(prices);
        int minCost = prices[0] + prices[1];

        if (minCost <= money) {
            return money - minCost;
        }
        return money;
        }
    }

Runtime: 2 ms, beating 79% of leetcode users solutions using java.
Memory: 44.49 mb, beating 5.58% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, and if statement.

### Solution Dec 21, 2023 (Java, leetcode) 1637. Widest Vertical Area Between Two Points Containing No Points (Medium)
In .LeetcodeDailySolution folder as Dec21,2023.java

#### Prompt:

Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.

A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.

Note that points on the edge of a vertical area are not considered included in the area.

#### Solution:

    class Solution {
    public int maxWidthOfVerticalArea(int[][] points) {
        int[] X = new int[points.length];
        
        for (int i = 0; i < points.length; i++) {
            X[i] = points[i][0];
        }
        Arrays.sort(X);

        int maxWidth = 0;

        for (int i = 1; i < X.length; i++) {
            int width = X[i] - X[i - 1];

            if (width > maxWidth) {
                maxWidth = width;
            }
        }
        return maxWidth;
        }
    }

Runtime: 13 ms, beating 98.07% of leetcode users solutions using java. 
Memory: 72.73 mb, beating 5.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, for loops, and if statement.

### Solution Dec 22, 2023 (Java, leetcode) 1422. Maximum Score After Splitting a String (Easy)
In .LeetcodeDailySolution folder as Dec22,2023.java

#### Prompt:

Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).

The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

#### Solution:

    class Solution {
    public int maxScore(String s) {
        int left = -1;
        int zeros = 0;
        int ones = 0;

        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) == '0') {
                zeros++;
            } else {
                ones++;
            }
            left = Math.max(left, zeros - ones);
        }
        if (s.charAt(s.length() - 1) == '1') {
            ones += 1;
        }
        return left + ones;       
        }
    }

Runtime: 1 ms, beating 97.83% of leetcode users solutions using java.
Memory: 41.36 mb, beating 34.35% of leetcode users solutions using java.

#### Concepts Applied:

For loops, charAt, strings, Math, else statement, and if statements. 

### Solution Dec 23, 2023 (Java, leetcode) 1496. Path Crossing (Easy)
In .LeetcodeDailySolution folder as Dec23,2023.java

#### Prompt:

Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.

Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.

#### Solution:

    class Solution {
    public boolean isPathCrossing(String path) {
        Map<Character, Pair<Integer, Integer>> moves = new HashMap();
        moves.put('N', new Pair(0, 1));
        moves.put('S', new Pair(0, -1));
        moves.put('W', new Pair(-1, 0));
        moves.put('E', new Pair(1, 0));
        
        Set<Pair<Integer, Integer>> visited = new HashSet();
        visited.add(new Pair(0, 0));
        
        int x = 0;
        int y = 0;
        
        for (Character c : path.toCharArray()) {
            Pair<Integer, Integer> curr = moves.get(c);
            int dx = curr.getKey();
            int dy = curr.getValue();
            x += dx;
            y += dy;
            
            Pair<Integer, Integer> pair = new Pair(x, y);
            
            if (visited.contains(pair)) {
                return true;
            }
            visited.add(pair);
        }
        return false;
        }
    }

Runtime: 1 ms, beating 96.48% of leetcode users solutions using java.
Memory: 42.31 mb, beating 5.29% of leetcode users solutions using java.

#### Concepts Applied:

Map, HashMap, Set, HashSet, Pairs, for loop, and if statement. 

### Solution Dec 24, 2023 (Java, leetcode) 1758. Minimum Charges To Make Alternating Binary String (Easy)
In .LeetcodeDailySolution folder as Dec24,2023.java

#### Prompt:

You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.

Return the minimum number of operations needed to make s alternating.

#### Solution:

    class Solution {
    public int minOperations(String s) {
        int n = s.length(), count = 0;

        if (n == 1) return 0;
        
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0 && s.charAt(i) == '1') count++;
            if (i % 2 == 1 && s.charAt(i) == '0') count++;
        }
        return Math.min(count, n - count); 
        }
    }

Runtime: 3 ms, beating 91.88% of leetcode users solutions using java.
Memory: 42.29 mb, beating 10.06% of leetcode users solutions using java.

#### Concepts Applied:

If statements, for loop, charAt, strings, and Math.

### Solution Dec 25, 2023 (Java, leetcode) 91. Decode Ways (Medium)
In .LeetcodeDailySolution folder as Dec25,2023.java 

#### Prompt:

A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

Given a string s containing only digits, return the number of ways to decode it.

The test cases are generated so that the answer fits in a 32-bit integer.

#### Solution:

    class Solution {
    public int numDecodings(String s) {
        int n=s.length();
        int[] dp=new int[n+1];

        dp[n]=1 ;

        for(int i = n-1 ; i >= 0 ; i--)
            if(s.charAt(i)!='0') {

                dp[i] = dp[i+1] ;
                
                if(i < n-1 && (s.charAt(i)=='1' || s.charAt(i)=='2' && s.charAt(i+1)<'7')) 
				    dp[i]+=dp[i+2];
            }
        return dp[0];   
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 41.78 mb, beating 10.62% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, for loop, if statements, and charAt.

### Solution Dec 26, 2023 (Java, leetcode) 1155. Number of Dice Rolls With Target Sum (Medium)
In .LeetcodeDailySolution folder as Dec26,2023.java

#### Prompt:

You have n dice, and each die has k faces numbered from 1 to k.

Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int numRollsToTarget(int d, int f, int target) {
        final int mod = 1000000007;

        int[] dp1 = new int[target + 1];  
        int[] dp2 = new int[target + 1];  

        dp1[0] = 1;

        for (int i = 1; i <= d; ++i) {

            int prev = dp1[0];  

            for (int j = 1; j <= target; ++j) {
                dp2[j] = prev; 
                prev = (int) ((prev + dp1[j]) % mod);

                if (j >= f) prev = (int) ((prev - dp1[j - f] + mod) % mod);
            }
            int[] temp = dp1;
            dp1 = dp2;
            dp2 = temp;
            dp2[0] = 0;
        }
        return dp1[target];
    	}
    }

Runtime: 5 ms, beating 94.68% of leetcode users solutions using java.
Memory: 40.54 mb, beating 78.19% of leetcode users solutions using java.

#### Concepts Applied:

Modulo, dynamic programming, for loops, and if statements.

### Solution Dec 27, 2023 (Java, leetcode) 1578. Minimum Time to Make Rope Colorful (Medium)
In .LeetcodeDailySolution folder as Dec27,2023.java

#### Prompt:

Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.

#### Solution:

    class Solution {
    public int minCost(String colors, int[] neededTime) {
        int time = 0;
        int n = colors.length();

        for (int i = 1; i < n; i++) {
            if (colors.charAt(i) == colors.charAt(i - 1)) {
                time += Math.min(neededTime[i], neededTime[i - 1]);
                neededTime[i] = Math.max(neededTime[i], neededTime[i - 1]);
           }
        }      
        return time;
   	}
    }

Runtime: 7 ms, beating 89.50% of leetcode users solutions using java.
Memory: 60.46 mb, beating 21.50% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statement, charAt, and Math.

### Solution Dec 28, 2023 (Java, leetcode) 1531. String Compression II (Hard)
In .LeetcodeDailySolution folder as Dec28,2023.java

#### Prompt:

Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".

Notice that in this problem, we are not adding '1' after single characters.

Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.

Find the minimum length of the run-length encoded version of s after deleting at most k characters.

#### Solution:

    class Solution {
    private int[][] memo = new int[101][101];
    private int recursion(String s, int i, int K) {
        int n = s.length();
        int k = K;

        if (n - i <= k) {
            return 0;
        }
        if (memo[i][k] != -1) {
            return memo[i][k];
        }
        int ans = k > 0 ? recursion(s, i + 1, k - 1) : 101;
        int c = 1;
        
        for (int j = i + 1; j <= n; j++) {

            ans = Math.min(ans, 1 + ((c > 99) ? 3 : (c > 9) ? 2 : (c > 1) ? 1 : 0) + 		recursion(s, j, k));

            if (j < n && s.charAt(i) == s.charAt(j)) {
                c++;
            } else if (--k < 0) {
                break;
            }
        }
        return memo[i][K] = ans;
    }
    public int getLengthOfOptimalCompression(String s, int k) {
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return recursion(s, 0, k);
      }
    }

Runtime: 42 ms, beating 73.33% of leetcode users solutions using java.
Memory: 42.29 mb, beating 51.11% of leetcode users solutions using java.

#### Concepts Applied:

Recursion, Math, charAt, if statements, for loops, else if statement, and Arrays.

### Solution Dec 29, 2023 (Java, leetcode) 1335. Minimum Difficulty of a Job Schedule (Hard)
In .LeetcodeDailySolution folder as Dec29,2023.java

#### Prompt:

You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day.

You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.

#### Solution:

    class Solution {
    public int minDifficulty(int[] jobDifficulty, int d){
        int jobs = jobDifficulty.length;
        
        if (jobs < d)
            return -1;

        int[][] dp = new int[d][jobs];

        dp[0][0] = jobDifficulty[0];
        
        for (int i = 1; i < jobs; i++)
            dp[0][i] = Math.max(dp[0][i - 1], jobDifficulty[i]);

        
        for (int days = 1; days < d; days++) {

            for (int i = days; i < jobs; i++) {
                int localMax = jobDifficulty[i];
                dp[days][i] = Integer.MAX_VALUE; 
                
                for (int j = i; j >= days; j--) {
                    localMax = Math.max(localMax, jobDifficulty[j]);
                    dp[days][i] = Math.min(dp[days][i], dp[days - 1][j - 1] + localMax);
                }
            }
        }
        return dp[d - 1][jobs - 1];
      }
    }

Runtime: 12 ms, beating 30.93% of leetcode users solutions using java.
Memory: 41.31 mb, beating 18.97% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, Math, for loops, and if statement.

### Solution Dec 30, 2023 (Java, leetcode) 1897. Redistribute Characters to Make All Strings Equal (Easy)
In .LeetcodeDailySolution folder as Dec30,2023.java

#### Prompt:

You are given an array of strings words (0-indexed).

In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].

Return true if you can make every string in words equal using any number of operations, and false otherwise.

#### Solution:

    class Solution {
    public boolean makeEqual(String[] words) {
        int[] counts = new int[26];

        for (String word : words) {
            for (char c : word.toCharArray()) {
                counts[c - 'a']++;
            }
        }
        int n = words.length;

        for (int val : counts) {
            if (val % n != 0) {
                return false;
            }
        }
        return true;
      }
    }

Runtime: 3 ms, beating 58.96% of leetcode users solutions using java.
Memory: 44.12 mb, beating 6.64% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, for loops, CharArray, and if statement.

### Solution Dec 31, 2023 (Java, leetcode) 1624. Largest Substring Between Two Equal Points (Easy)
In .LeetcodeDailySolution folder as Dec31,2023.java

#### Prompt:

Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
    int maxDistance = -1;
    
    for (int i = 0; i < s.length() - 1; i++) {
        for (int j = s.length() - 1; j > i; j--) {
            if (s.charAt(i) == s.charAt(j)) {
                maxDistance = Math.max(maxDistance, j - i - 1);
                break;
            }
        }
    }
 	return maxDistance;
      }
    }

Runtime: 4 ms, beating 32.42% of leetcode users solutions using java.
Memory: 41.35 mb, beating 13.97% of leetcode users solutions using java.

#### Concepts Applied:

For loops, if statement, charAt, and Math.

### Solution Jan 1, 2024 (Java, leetcode) 455. Assign Cookies (Easy)
In .LeetcodeDailySolution folder as Jan1,2024.java

#### Prompt:

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

#### Solution:

    class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);

        int i = 0;

        for(int j=0;i<g.length && j<s.length;j++)
	        if(g[i]<=s[j]) i++;
            
        return i;
      }
    }

Runtime: 8 ms, beating 98.87% of leetcode users solutions using java.
Memory: 44.91 mb, beating 28.82% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, and for loop.

### Solution Jan 2, 2024 (Java, leetcode) 2610. Convert an Array Into a 2D Array (Medium)
In .LeetcodeDailySolution folder as Jan2,2024.java

#### Prompt:

You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:

The 2D array should contain only the elements of the array nums.
Each row in the 2D array contains distinct integers.
The number of rows in the 2D array should be minimal.
Return the resulting array. If there are multiple answers, return any of them.

Note that the 2D array can have a different number of elements on each row.

#### Solution:

    class Solution {
    public List<List<Integer>> findMatrix(int[] nums) {
    int n = nums.length;

    Arrays.sort(nums);

    List<List<Integer>> ans = new ArrayList<>();
    int k = 0;

    for(int i = 0; i < n; i++){
        if(ans.size() <= k) ans.add(new ArrayList<>());
        ans.get(k).add(nums[i]);
        if(i+1 < n && nums[i] != nums[i+1])  k=0;
        else k++;
        }
    return ans;
      }
    }

Runtime: 4 ms, beating 55.24% of leetcode users solution using java.
Memory: 45.13 mb, beating 10.26% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, List, ArrayList, matrix, for loop, if statements, and else statement.

### Solution Jan 3, 2024 (Java, leetcode) 2125. Number of Laser Beams in a Bank (Medium)
In .LeetcodeDailySolution folder as Jan3,2024.java

#### Prompt:

Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.

There is one laser beam between any two security devices if both conditions are met:

The two devices are located on two different rows: r1 and r2, where r1 < r2.
For each row i where r1 < i < r2, there are no security devices in the ith row.
Laser beams are independent, i.e., one beam does not interfere nor join with another.

Return the total number of laser beams in the bank.

#### Solution: 

    class Solution {
    public int numberOfBeams(String[] bank) {

        if (bank.length < 2) {
            return 0;
        }
        int solution = 0;
        int beaconsInPrevRow = 0;
        int beaconsInCurrentRow = 0;

        for (String row : bank) {
            beaconsInCurrentRow = 0;

            for (char c : row.toCharArray()) {
                if (c == '1') {
                    beaconsInCurrentRow++;
                }
            }
            solution += beaconsInCurrentRow * beaconsInPrevRow;
            beaconsInPrevRow = beaconsInCurrentRow == 0 ? beaconsInPrevRow : beaconsInCurrentRow;
        }
        return solution;
      }
    }

Runtime: 11 ms, beating 91.49% of leetcode users solutions using java.
Memory: 44.89 mb, beating 33.27% of leetcode users solutions using java.

#### Concepts Applied:

If statements, for loops, strings, matrix, and charArray.

## Made a switch to C++ for all future solutions

### Solution Jan 4, 2024 (C++, leetcode) 2870. Minimum Number of Operations to Make Array Empty (Medium)
In .LeetcodeDailySolution folder as Jan4,2024.cpp

#### Prompt:

You are given a 0-indexed array nums consisting of positive integers.

There are two types of operations that you can apply on the array any number of times:

Choose two elements with equal values and delete them from the array.
Choose three elements with equal values and delete them from the array.
Return the minimum number of operations required to make the array empty, or -1 if it is not possible.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<int>& nums) {
        int ans = 0;

        unordered_map<int, int> freq;
        for(auto n: nums) freq[n]++;
        for(auto [k,f]: freq){
            if(f == 1) return -1;
            ans += f/3 + (f%3 + 1)/2;
        }
        return ans;
      }
    };

Runtime: 122 ms, beating 56.03% of leetcode users solutions using C++.
Memory: 85.06 mb, beating 89.98% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays (vector), unordered map, for loops, and if statement.

### Solution Jan 5, 2024 (C++, leetcode) 300. Longest Increasing Subsequence (Medium)
In .LeetcodeDailySolution folder as Jan5,2024.cpp

#### Prompt:

Given an integer array nums, return the length of the longest strictly increasing 
subsequence.

#### Solution:

    class Solution {
    public:
    int lengthOfLIS(std::vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int n = nums.size();
        std::vector<int> dp(n, 1);

        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    dp[i] = std::max(dp[i], dp[j] + 1);
                }
            }
        }
        return *std::max_element(dp.begin(), dp.end());
      }
    };

Runtime: 243 ms, beating 52.49% of leetcode users solutions C++.
Memory: 10.87 mb, beating 62.25% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, if statements, dynamic programming, and for loops.

### Solution Jan 6, 2024 (C++, leetcode) 1235. Maximum Profit in Job Scheduling (Hard)
In .LeetcodeDailySolution folder as Jan6,2024.cpp

#### Prompt:

We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.

#### Solution:

    class Solution {
    public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        const int n = startTime.size();

        vector<vector<int>> jobs(n);

        for (int i = 0; i < n; i++) jobs[i] = {endTime[i], startTime[i], profit[i]};
        sort(jobs.begin(), jobs.end());

        map<int, int> dp = {{0, 0}};
        
        for (auto& job : jobs) {
            int profit = prev(dp.upper_bound(job[1]))->second + job[2];
            if (profit > dp.rbegin()->second) dp[job[0]] = profit;
        }
        return dp.rbegin()->second;
      }
    };

Runtime: 187 ms, beating 58.92% of leetcode users solutions using C++.
Memory: 75.94 mb, beating 57.04% of leetcode users solutions using C++.

#### Concepts Applied:

Hash table, dynamic programming, for loops, sorting, map, and if statement.

### Solution Jan 7, 2024 (C++, leetcode) 446. Arithmetic Slices II - Subsequence (Hard)
In .LeetcodeDailySolution folder as Jan7,2024.cpp

#### Prompt:

Given an integer array nums, return the number of all the arithmetic subsequences of nums.

A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
The test cases are generated so that the answer fits in 32-bit integer.

#### Solution:

    class Solution {
    public:
    int numberOfArithmeticSlices(std::vector<int>& nums) {
        int n = nums.size();
        int total_count = 0;

        std::vector<std::unordered_map<int, int>> dp(n);

        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {

                long long diff = static_cast<long long>(nums[i]) - nums[j]; 

                if (diff > INT_MAX || diff < INT_MIN)
                    continue; 

                int diff_int = static_cast<int>(diff);

                dp[i][diff_int] += 1; 

                if (dp[j].count(diff_int)) {
                    dp[i][diff_int] += dp[j][diff_int];
                    total_count += dp[j][diff_int];
                }
            }
        }
        return total_count;
      }
    };

Runtime: 411 ms, beating 75.28% of leetcode users solutions using C++.
Memory: 109.88 mb, beating 73.33% of leetcode users solutions using C++.

#### Concepts Applied:

Vector, unordered map, for loops, if statements, and dynamic programming.

### Solution Jan 8, 2024 (C++, leetcode) 938. Range Sum of BST (Easy)
In .LeetcodeDailySolution folder as Jan8,2024.cpp

#### Prompt:

Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].

#### Solution:

    class Solution {
    public:
    int rangeSumBST(TreeNode* root, int low, int high) {

        if (!root) {
            return 0;
        }
        int currentVal = (root->val >= low && root->val <= high) ? root->val : 0;
        int leftSum = rangeSumBST(root->left, low, high);
        int rightSum = rangeSumBST(root->right, low, high);

        return currentVal + leftSum + rightSum;
      }
    };

Runtime: 92 ms, beating 79.17% of leetcode users solutions using C++.
Memory: 64.95 mb, beating 51.83% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search tree, tree, binary tree, and depth-first-search.

### Solution Jan 9, 2024 (C++, leetcode) 872. Leaf-Similar Trees (Easy)
In .LeetcodeDailySolution folder as Jan9,2024.cpp

#### Prompt:

Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/44e59039-7152-4bac-a956-623595860368)

For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).

Two binary trees are considered leaf-similar if their leaf value sequence is the same.

Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.

#### Solution:

    class Solution {
    public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {

        function<void(TreeNode*, vector<int>&)> collectLeafValues =
            [&](TreeNode* root, vector<int>& leafValues) {

                if (!root) {
                    return;
                }
                if (!root->left && !root->right) {
                    leafValues.push_back(root->val);
                }
                collectLeafValues(root->left, leafValues);
                collectLeafValues(root->right, leafValues);
            };
        vector<int> leafValues1, leafValues2;

        collectLeafValues(root1, leafValues1);
        collectLeafValues(root2, leafValues2);

        return leafValues1 == leafValues2;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.91 mb, beating 8.99% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First-Search, and binary tree.

### Solution Jan 10, 2024 (C++, leetcode) 2385. Amount of Time for Binary Tree to Be Infected (Medium)
In .LeetcodeDailySolution folder as Jan10,2024.cpp

#### Prompt:

You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.

Each minute, a node becomes infected if:

The node is currently uninfected.
The node is adjacent to an infected node.
Return the number of minutes needed for the entire tree to be infected.

#### Solution:

    class Solution {
    public:
    int result;
    int amountOfTime(TreeNode* root, int start) {
        DFS(root, start);
        return result;
    }
    int DFS(TreeNode* node, int start){
        if(node == NULL) return 0;

        int leftDepth = DFS(node->left, start);
        int rightDepth = DFS(node->right, start);

        if(node->val == start){
            result = std::max(leftDepth, rightDepth);
            return -1;
        }
        else if(leftDepth >= 0 && rightDepth >= 0)
            return std::max(leftDepth, rightDepth)+1;
        
        result = std::max(result, std::abs(leftDepth - rightDepth));
        
        return std::min(leftDepth, rightDepth) - 1;
      }
    };

Runtime: 136 ms, beating 93.33% of leetcode users solutions using C++.
Memory: 90.57 mb, beating 99.40% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First-Search, Breadth-First-Search, and binary tree.

### Solution Jan 11, 2024 (C++, leetcode) 1026. Maximum Difference Between Node and Ancestor (Medium)
In .LeetcodeDailySolution folder as Jan11,2024.cpp

#### Prompt:

Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.

A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.

#### Solution:

    class Solution {
    public:
    int maxAncestorDiff(TreeNode* root) {
        if (!root)
            return 0;

        int minVal = root->val, maxVal = root->val;

        differ(root, minVal, maxVal);

        return diff;
    }
    public:
    int diff = 0;
    void differ(TreeNode* root, int minVal, int maxVal) {
        if (!root)
            return;

        diff = max(diff, max(abs(minVal - root->val), abs(maxVal - root->val)));
        minVal = min(minVal, root->val);
        maxVal = max(maxVal, root->val);
        differ(root->left, minVal, maxVal);
        differ(root->right, minVal, maxVal);
      }
    };

Runtime: 3 ms, beating 85.85% of leetcode users solutions using C++.
Memory: 10.07 mb, beating 79.90% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First Search, binary tree, and recursion.

### Solution Jan 12, 2024 (C++, leetcode) 1704. Determine in String Halves Are Alike (Easy)
In .LeetcodeDailySolution folder as Jan12,2024.cpp

#### Prompt:

You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.

Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.

Return true if a and b are alike. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool vow(char c){
        c=tolower(c);

        return (c=='a'||c=='e'||c=='i'||c=='o'||c=='u');
    }
    bool halvesAreAlike(string s) {

        int x=0,n=s.size();
        
        for(int i=0;i<n/2;i++){
            if(vow(s[i])) x++;
            if(vow(s[n-i-1])) x--;
        }
        return x==0;
      }
    };

Runtime: 2 ms, beating 64.10% of leetcode users solutions using C++.
Memory: 6.98 mb, beating 73.08% of leetcode ysers solutions using C++.

#### Concepts Applied:

Bool, char, unordered set, for loop, and if statement.

### Solution Jan 13, 2024 (C++, leetcode) 1347. Minimum Number of Steps to Make Two Strings Anagram (Medium)
In .LeetcodeDailySolution folder as Jan13,2024.cpp

#### Prompt:

You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.

Return the minimum number of steps to make t an anagram of s.

An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.

#### Solution:

    class Solution {
    public:
    int minSteps(string s, string t) {

        vector<int> m1(26, 0), m2(26, 0);

        for(auto c : s) m1[c-'a']++;
        for(auto c : t) m2[c-'a']++;

        int ans = 0;
        
        for(int i = 0;i < 26;i++){
            if(m1[i] > m2[i]) ans += m1[i] - m2[i]; 
        }
        return ans;
      }
    };

Runtime: 50 ms, beating 73.78% of leetcode users solutions using C++.
Memory: 16.86 mb, beating 82.35% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, counting, vector, for loop, and if statement. 
