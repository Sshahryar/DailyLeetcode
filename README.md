# Leetcode

Repository of my Leetcode journey, starting September 23, 2023. 

Including my solutions for daily challenges, problems and contests. 

Leetcode is a website for technical interview preparation that offers coding problems, challenges, contests, enhancement of problem-solving skills, algorithms and data structures. 

My profile is linked below:

https://leetcode.com/Sshahryar/

Below will be updates on the Daily Challenge Solutions**. Info on other folders in the repository such as courses, challenges, etc. can be found in the wiki. 

**The daily challenge updates are based on this title format: Solution (date) (language, leetcode) (name of challenge) (difficulty). 

**The daily challenge solutions are designed to work on the leetcode, and may or may not work on ide's outside of 
leetcode, because of test cases and specific parameters. 

## Leetcode Daily Challenge Solutions (From .LeetcodeDailySolution)

### Solution Sept 23, 2023 (Java, leetcode) 1048. LongestStrChain (Medium) 

In .LeetcodeDailySolution folder as Sept23,2023.java

#### Prompt:

You are given an array of words where each word consists of lowercase English letters.

wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.

For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".
A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.

Return the length of the longest possible word chain with words chosen from the given list of words.

#### Solution:

    class Solution {
        public int longestStrChain(String[] words) {
            int ans = 0;
            Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));
        
        Map<String, Integer> dp = new HashMap<String, Integer>();
        
        for (String w: words) {
            int best = 0;
            for (int i = 0; i < w.length(); i++) {
                String prev = w.substring(0, i) + w.substring(i + 1);
                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);
            }
            dp.put(w, best);
            ans = Math.max(ans, best);
        }
        return ans;
    }
    }

Runtime: 41 ms, beating 31.27% of leetcode users solutions using java.
Memory: 43.9 mb, beating 34.67% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, arrays, map, and hashmap.
    
### Solution Sept 25, 2023 (Java, leetcode) 389. Find the Difference (Easy)
In .LeetcodeDailySolution folder as Sept25,2023.java

#### Prompt:

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

#### Solution:

    class Solution {
        public char findTheDifference(String s, String t) {
            int[] charCount = new int[26];
        
        for (char c : s.toCharArray()) {
            charCount[c - 'a']++;
        }
        
        for (char c : t.toCharArray()) {
            charCount[c - 'a']--;
        }
        
        for (int i = 0; i < 26; i++) {
            if (charCount[i] < 0) {
                return (char) (i + 'a');
            }
        }
        
        return ' ';
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String s = "abcd";
        String t = "abcde";
        char addedLetter = solution.findTheDifference(s, t);
        System.out.println("The added letter is: " + addedLetter);
    }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 40.9 mb, beating 20.52% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays and for loop. 

### Solution Sept 26, 2023 (Java, leetcode) 316. Remove Duplicate Letters (Medium) 
In .LeetcodeDailySolution folder as Sept26,2023.java

#### Prompt:

Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is 
the smallest in lexicographical order among all possible results.
 
#### Solution:

    import java.util.Stack;

    class Solution {
    public String removeDuplicateLetters(String s) {
        int[] count = new int[26];
        boolean[] used = new boolean[26];
        Stack<Character> stack = new Stack<>();

        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }

        for (char c : s.toCharArray()) {
            count[c - 'a']--;
            if (used[c - 'a']) {
                continue;
            }

            while (!stack.isEmpty() && c < stack.peek() && count[stack.peek() - 'a'] > 0) {
                used[stack.pop() - 'a'] = false;
            }

            stack.push(c);
            used[c - 'a'] = true;
        }

        StringBuilder result = new StringBuilder();
        for (char c : stack) {
            result.append(c);
        }

        return result.toString();
    }
    }
    
Runtime: 2 ms, beating 96.27% of leetcode users solutions using java.
Memory: 41.1 mb, beating 62.98% of leetcode users solutions using java.

#### Concepts Applied:

CharacterArray and stack. 

### Solution Sept 27, 2023 (Java, leetcode) 880. Decoded String at Index (Medium)
In .LeetcodeDailySolution folder as Sept27,2023.java

#### Prompt:

You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:

If the character read is a letter, that letter is written onto the tape.
If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.
Given an integer k, return the kth letter (1-indexed) in the decoded string.

#### Solution:

    class Solution {
    public String decodeAtIndex(String encodedString, int k) {
       Stack<Long> characterLengths = new Stack<>();

        characterLengths.push(0L); 

        for (int i = 0; i < encodedString.length(); i++) {
            char c = encodedString.charAt(i);
            if (Character.isDigit(c)) {

                long length = characterLengths.peek() * (c - '0');
                characterLengths.push(length);
            } else {

                long length = characterLengths.peek() + 1;
                characterLengths.push(length);
            }
        }

        int ln = characterLengths.size();
        while (!characterLengths.isEmpty()) {
            k %= characterLengths.peek(); 
            ln--;

            if (k == 0 && Character.isLetter(encodedString.charAt(ln - 1))) {
                return String.valueOf(encodedString.charAt(ln - 1));
            }


            characterLengths.pop();
        }

        return ""; 
    }
    }

Runtime: 1 ms, beating 13.46% of leetcode users solutions using java.
Memory: 40.8 mb, beating 8.48% of leetcode users solutions using java.

#### Concepts Applied:

Strings, stack, character lengths, e.t.c

### Solution Sept 28, 2023 (Java, leetcode) 905. Sort Array by Parity (Easy)
In .LeetcodeDailySolution folder as Sept28,2023.java

#### Prompt:

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

#### Solution:

    class Solution {
      public int[] sortArrayByParity(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            if (nums[left] % 2 == 0) {
                left++;  

            } else if (nums[right] % 2 == 1) {
                right--;  

            } else {
                
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
                right--;
            }
        }

        return nums;
     }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 44.1 mb, beating 40.77% of leetcode users solutions using java.

#### Concepts Applied:

While loop, if and else-if. 

### Solution Sept 29, 2023 (Java, leetcode) 896. Monotonic Array (Easy)
In .LeetcodeDailySolution folder as Sept29,2023.java

#### Prompt: 

An array is monotonic if it is either monotone increasing or monotone decreasing.

An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].

Given an integer array nums, return true if the given array is monotonic, or false otherwise.

#### Solution:

    class Solution {
       public boolean isMonotonic(int[] nums) {
        boolean increasing = true;
        boolean decreasing = true;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i - 1] > nums[i]) {
                increasing = false; 
            } else if (nums[i - 1] < nums[i]) {
                decreasing = false; 
            }
            
            if (!increasing && !decreasing) {
                return false;
            }
        }

        return true; 
      }
    }

Runtime: 2 ms, beating 58.97% of leetcode users solutions using java.
Memory: 54.4 mb, beating 73.26% of leetcode users solutions using java.

#### Concepts Applied:

Booleans, for loop, if, and else-if. 

### Solution Sept 30, 2023 (Java, leetcode) 456. 132 Pattern (Medium)
In .LeetcodeDailySolution folder as Sept30,2023.java

#### Prompt:

Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].

Return true if there is a 132 pattern in nums, otherwise, return false.

Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
 
Constraints:

n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109

#### Solution:

    import java.util.Stack;

    class Solution {
       public boolean find132pattern(int[] nums) {
        int n = nums.length;
        int[] minLeft = new int[n];
        minLeft[0] = nums[0];
        
        for (int i = 1; i < n; i++) {
            minLeft[i] = Math.min(minLeft[i - 1], nums[i]);
        }
        
        Stack<Integer> stack = new Stack<>();
        
        for (int j = n - 1; j >= 0; j--) {
            if (nums[j] > minLeft[j]) {
                while (!stack.isEmpty() && stack.peek() <= minLeft[j]) {
                    stack.pop();
                }
                if (!stack.isEmpty() && stack.peek() < nums[j]) {
                    return true;
                }
                stack.push(nums[j]);
            }
        }
        
        return false;
      }
    }

Runtime: 15 ms, beating 68.8% of leetcode users solutions using java.
Memory: 64.1 mb, beating 8.57% of leetcode users solutions using java.

#### Concepts Applied:

Stack, for and while loop. 

### Solution Oct 1, 2023 (Java, leetcode) 557. Reverse Words In a String III (Easy) 
In .LeetcodeDailySolution folder as Oct1,2023.java

#### Prompt:

Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

Example 1:

Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
Example 2:

Input: s = "God Ding"
Output: "doG gniD"

Constraints:

1 <= s.length <= 5 * 104
s contains printable ASCII characters.
s does not contain any leading or trailing spaces.
There is at least one word in s.
All the words in s are separated by a single space.

#### Solution:

    class Solution {
       public String reverseWords(String s) {
          String[] words = s.split(" "); 

        StringBuilder result = new StringBuilder();

        for (String word : words) {
            
            result.append(reverseWord(word)).append(" ");
        }

        return result.toString().trim(); 

    }

    private String reverseWord(String word) {
        char[] chars = word.toCharArray(); 
        int left = 0;
        int right = chars.length - 1;

        while (left < right) {

            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;

            left++;
            right--;
        }

        return new String(chars); 
      }
    }

Runtime: 4 ms, beating 87.77% of leetcode users solutions using java.
Memory: 43.9 mb, beating 85.88% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays, for and while loop. 

### Solution Oct 2, 2023 (Java, leetcode) 2038. Remove Colored Pieces if Both Neighbors are the Same (Medium) 
In .LeetcodeDailySolution folder as Oct2,2023.java

#### Prompt:

There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.

Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.

Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
Alice and Bob cannot remove pieces from the edge of the line.
If a player cannot make a move on their turn, that player loses and the other player wins.
Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.

#### Solution:

    class Solution {
      public boolean winnerOfGame(String colors) {
        int n = colors.length();
        int aliceCount = 0;
        int bobCount = 0;
        
        for (int i = 1; i < n - 1; i++) {
            if (colors.charAt(i) == 'A' && colors.charAt(i - 1) == 'A' && colors.charAt(i +         1) == 'A') {
                aliceCount++;
            } else if (colors.charAt(i) == 'B' && colors.charAt(i - 1) == 'B' && colors.    charAt(i + 1) == 'B') {
                bobCount++;
            }
        }
        
        return aliceCount > bobCount;
      }
    }

Runtime: 16 ms, beating 52.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 55.98% of leetcode users solutions using java. 

#### Concepts Applied:

Strings, for loop, if, else-if, and charAt. 

### Solution Oct 3, 2023 (Java, leetcode) 1512. Number of Good Pairs (Easy) 
In .LeetcodeDailySolution folder as Oct3,2023.java

#### Prompt:

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

#### Solution:

    class Solution {
       public int numIdenticalPairs(int[] nums) {
           int[] count = new int[101]; 

        for (int num : nums) {
            count[num]++;
        }
        
        int goodPairs = 0;
        
        for (int c : count) {
            if (c > 1) {
                goodPairs += (c * (c - 1)) / 2;
            }
        }
        
        return goodPairs;
      }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40 mb, beating 34.61% of leetcode users solutions using java. 

#### Concepts Applied:

For loop.

### Solution Oct 4, 2023 (Java, leetcode) 706. Design HashMap (Easy)
In .LeetcodeDailySolution folder as Oct4,2023.java

#### Prompt:

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

#### Solution

    import java.util.ArrayList;
    import java.util.List;
  
    class MyHashMap {

    private static final int SIZE = 1000;
    private List<List<int[]>> data;

    public MyHashMap() {
        data = new ArrayList<>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            data.add(new ArrayList<>());
        }
    }

    private int getIndex(int key) {
        return Integer.hashCode(key) % SIZE;
    }

    public void put(int key, int value) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                entry[1] = value;
                return;
            }
        }
        data.get(index).add(new int[]{key, value});
    }

    public int get(int key) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                return entry[1];
            }
        }
        return -1;
    }

    public void remove(int key) {
        int index = getIndex(key);
        List<int[]> entries = data.get(index);
        for (int i = 0; i < entries.size(); i++) {
            if (entries.get(i)[0] == key) {
                entries.remove(i);
                return;
            }
        }
      }
    }

    public class Main {
      public static void main(String[] args) {
        MyHashMap myHashMap = new MyHashMap();
        myHashMap.put(1, 1);
        myHashMap.put(2, 2);
        System.out.println(myHashMap.get(1)); 
        System.out.println(myHashMap.get(3)); 
        myHashMap.put(2, 1);
        System.out.println(myHashMap.get(2)); 
        myHashMap.remove(2);
        System.out.println(myHashMap.get(2)); 
      }
    }

Runtime: 17 ms, beating 65.77% of leetcode users using java.
Memory: 47.6 mb, beating 69.68% of leetcode users using java.

#### Concepts Applied:

Array, hash table, linked list, design, and hash function.

### Soluton Oct 5, 2023 (Java, leetcode) 229. Majorty Element II (Medium)
In .LeetcodeDailySolution folder as Oct5,2023.java

#### Prompt:

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

#### Solution:

    import java.util.ArrayList;
    import java.util.List;

    class Solution {
      public List<Integer> majorityElement(int[] nums) {
        List<Integer> result = new ArrayList<>();
        int n = nums.length;

        if (n == 0) return result;

        int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;

        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            } else if (count1 == 0) {
                candidate1 = num;
                count1 = 1;
            } else if (count2 == 0) {
                candidate2 = num;
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }

        count1 = 0;
        count2 = 0;
        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            }
        }

        if (count1 > n / 3) {
            result.add(candidate1);
        }
        if (count2 > n / 3) {
            result.add(candidate2);
        }

        return result;
      }
    }

Runtime: 1 ms, beating 99.94% of leetcode users solutions using java. 
Memory: 47.2 mb, beating 10.66% of leetcode users solutions using java.

#### Concepts Applied:

Array, hash table, sorting, and counting.

### Solution Oct 6, 2023 (Java, leetcode) 343. Integer Break (Medium)
In .LeetcodeDailySolution folder as Oct6,2023.java

#### Prompt:

Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

Return the maximum product you can get.

#### Solution:

    class Solution {
        public int integerBreak(int n) {
                if(n == 1) return 1;
                        int[] dp = new int[n + 1];
                                dp[1] = 1;
                                        for(int i = 2; i <= n; i++){
                                                    for(int j = 1; j < i; j++){
                                                                    dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                                                                                }
                                                                                        }
                                                                                                return dp[n];
                                                                                                    }
                                                                                                    }
                                                                                                    
Runtime: 1 ms, beating 33.22% of leetcode users solutions using java.
Memory: 39.9 mb, beating 6.52% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming and for loop.

### Solution Oct 7, 2023 (Java, leetcode) 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons (Hard)
Im .LeetcodeDailySolution folder as Oct7,2023.java

#### Prompt:

You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/213847ce-4a27-441a-9b8a-06910e1736ce)

You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.

#### Solution:

    class Solution {
        public int numOfArrays(int n, int m, int k) {
        long[][][] dp = new long[n][k][m];
        long mod = 1000000007;
        Arrays.fill(dp[0][0], 1);
        
        for (int i = 1; i < n; i++) {
            for (int cost = 0; cost < Math.min(i + 1, k); cost++) {
                for (int max = 0; max < m; max++) {
                    dp[i][cost][max] = (dp[i][cost][max] + (max + 1) * dp[i - 1][cost][max]) % mod;
                    if (cost != 0) {
                        long sum = 0;
                        for (int prevMax = 0; prevMax < max; prevMax++) {
                            sum += dp[i - 1][cost - 1][prevMax];
                            sum %= mod;
                        }
                        dp[i][cost][max] = (dp[i][cost][max] + sum) % mod;
                    }
                }
            }
        }
        long ans = 0;
        for (int max = 0; max < m; max++) {
            ans += dp[n - 1][k - 1][max];
            ans %= mod;
        }
        return (int) ans;
      }
    }

Runtime: 27 ms, beating 85.37% of leetcode users solutions using java.
Memory: 43.6 mb, beating 24.29% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, dynamic programming, and if statements.

### Solution Oct 8, 2023 (Java, leetcode) 1458. Max Dot Product of Two Subtances (Hard)
In .LeetcodeDailySolutions folder as Oct8,2023.java

#### Prompt:

Given two arrays nums1 and nums2.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).

#### Solution:

    class Solution {
        public int maxDotProduct(int[] nums1, int[] nums2) {
        int[][] marks = new int[nums1.length][nums2.length];
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                int max = nums1[i] * nums2[j];
                if (i > 0 && j > 0) {
                    max = Math.max(max, max + marks[i - 1][j - 1]);
                }
                if (i > 0) {
                    max = Math.max(max, marks[i - 1][j]);
                }
                if (j > 0) {
                    max = Math.max(max, marks[i][j - 1]);
                }
                marks[i][j] = max;
            }
        }
        return marks[nums1.length - 1][nums2.length - 1];
      }
    }
    
Runtime: 10 ms, beating 81.94% of leetcode users solutions using java.
Memory: 42.9 mb, beating 80.56% of leetcode users solutions using java.

#### Concepts Applied:

Math, for-loop and if statements.

### Solution Oct 9, 2023 (Java, leetcode) 34. Find First and Last Position of Element in Sorted Array (Medium)
In .LeetcodeDailySolution folder as Oct9,2023.java

#### Prompt:

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

#### Solution:

    class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first = -1, last = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                if (first == -1) {
                    first = i;
                }
                last = i;
            }
        }
        return new int[]{first, last};
      }
    }

Runtime: 1 ms, beating 20.94% of leetcode users solutions using java.
Memory: 44.1 mb, beating 82.90% of leetcode users solutions using java. 

#### Concepts Applied:

If statements.

### Solution Oct 10, 2023 (Java, leetcode) 2009. Minimum Number of Operation to Make Array Continuous
In .LeetcodeDailySolution folder as Oct10,2023.java

#### Prompt:

You are given an integer array nums. In one operation, you can replace any element in nums with any integer.

nums is considered continuous if both of the following conditions are fulfilled:

All elements in nums are unique.
The difference between the maximum element and the minimum element in nums equals nums.length - 1.
For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.

Return the minimum number of operations to make nums continuous.

#### Solution:

    class Solution {
      public int minOperations(int[] nums) {
        Arrays.sort(nums);
        int uniqueLen = 1;
        for (int i = 1; i < nums.length; ++i) {
            if (nums[i] != nums[i - 1]) {
                nums[uniqueLen++] = nums[i];
            }
        }
        
        int ans = nums.length;
        for (int i = 0, j = 0; i < uniqueLen; ++i) {
            while (j < uniqueLen && nums[j] - nums[i] <= nums.length - 1) {
                ++j;
            }
            ans = Math.min(ans, nums.length - (j - i));
        }
        
        return ans;
      }
    }

Runtime: 36 ms, beating 99.3% of leetcode users solutions using java.
Memory: 58 mb, beating 43.69% of leetcode users solutons using java.

#### Concepts Applied:

Arrays, for loop, while loop, and if statements.

### Solution Oct 11, 2023 (Java, leetcode) 2251. Numbers of Flowers in Full Bloom (Hard)
In .LeetcodeDailySolution folder as Oct11,2023.java

#### Prompt: 

You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the ith person will arrive to see the flowers.

Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.

Example 1:

Input: flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]
Output: [1,2,2,2]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

Example 2:

Input: flowers = [[1,10],[3,3]], people = [3,3,2]
Output: [2,2,1]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

#### Solution:

    class Solution {
    public int[] fullBloomFlowers(int[][] flowers, int[] persons) {
        int n = persons.length;
        int[] result = new int[n];

        TreeMap<Integer, Integer> treeMap = new TreeMap<>();
        for (int i = 0; i < flowers.length; i++) {
        
            treeMap.put(flowers[i][0], treeMap.getOrDefault(flowers[i][0], 0) + 1);

            treeMap.put(flowers[i][1] + 1, treeMap.getOrDefault(flowers[i][1] + 1, 0) - 1);
        }
        
        TreeMap<Integer, Integer> sum = new TreeMap<>();
        int prev = 0;
        for (Map.Entry<Integer, Integer> entry : treeMap.entrySet()) {
            prev += entry.getValue();
            sum.put(entry.getKey(), prev);
        }

        for (int i = 0; i < n; i++) {

            Map.Entry<Integer, Integer> entry = sum.floorEntry(persons[i]);
            if (entry != null) {
                result[i] = entry.getValue(); 
            }
        }
        return result;
        }
    }

Runtime: 102 ms, beating 19.78% of leetcode users using java.
Memory: 73.5 mb, beating 22.1% of leetcode users using java.

#### Concepts Applied:

Treemap, for loop, and if statements. 

### Solution Oct 12, 2023 (Java, leetcode) 1095. Find in Mountain Array (Hard)
In .LeetcodeDailySolution folder as Oct12,2023.java

#### Prompt:

(This problem is an interactive problem.)

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.

You cannot access the mountain array directly. You may only access the array using a MountainArray interface:

MountainArray.get(k) returns the element of the array at index k (0-indexed).
MountainArray.length() returns the length of the array.
Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.

#### Solution:
     
    class Solution {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int length = mountainArr.length();
        int peakIndex = findPeak(mountainArr, length);

        int result = findTarget(mountainArr, 0, peakIndex, target, true);
        if (result != -1) {
            return result;
        }

        return findTarget(mountainArr, peakIndex + 1, length - 1, target, false);
    }

    private int findTarget(MountainArray mountainArr, int left, int right, int target, boolean isUpside) {
        while (left <= right) {
            int mid = (left + right) / 2;
            int midVal = mountainArr.get(mid);

            if (midVal == target) {
                return mid;
            }

            if (isUpside) {
                if (target > midVal) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else {
                if (target > midVal) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }

        return -1;
    }

    private int findPeak(MountainArray mountainArr, int length) {
        int left = 0;
        int right = length - 1;

        while (left < right) {
            int mid = (left + right) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.9 mb, beating 85.75% of leetcode users solutions using java.

#### Concepts Applied: 

Dynamic programming, math and for loop.

### Solution Oct 13, 2023 (Java, leetcode) 746. Min Cost Climbing Stairs (Easy)
In .LeetcodeDailySolution folder as Oct13,2023.java

#### Prompt:

You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

#### Solution:

    class Solution {

    public int minCostClimbingStairs(int[] cost) {

        int n = cost.length;

        int[] dp = new int[n];

        dp[0] = cost[0];

        dp[1] = cost[1];

        

        for (int i = 2; i < n; i++) {

            dp[i] = cost[i] + Math.min(dp[i-1], dp[i-2]);

        }

        

        return Math.min(dp[n-1], dp[n-2]);

        }

    }
    
Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.1 mb, beating 24.85% of leetcode users solutions using java.

#### Concepts Applied:

Dyanmic programming, math and for loop.

### Solution Oct 14, 2023 (Java, leetcode) 2742. Painting the Walls (Hard)
In .LeetcodeDailySolution folder as Oct14,2023.java

#### Prompt:

You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:

A paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.
A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.
Return the minimum amount of money required to paint the n walls.

#### Solution:

    class Solution {
    public int paintWalls(int[] cost, int[] time) {
        int n = cost.length;
        int[] money = new int[n+1];
        Arrays.fill(money,(int)1e9);
        money[0]=0;
        for(int i=0;i<n;i++)
        {
            for(int j=n;j>0;j--)
            {
                money[j]=Math.min(money[j],money[Math.max(j-time[i]-1,0)]+cost[i]);
            }
        }
        return money[n];
        }
    }

Runtime: 8 ms, beating 98.47% of leetcode users solutions using java.
Memory: 43.3 mb, beating 95.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, math and for loop. 

### Solution Oct 15, 2023 (Java, leetcode) 1269. Number of Ways to Stay in the Same Place After Some Steps (Hard)
In .LeetcodeDailySolution as Oct15,2023.java

#### Prompts:

You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).

Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int numWays(int steps, int arrLen) {
        int m = steps;
        int n = Math.min(steps / 2 + 1, arrLen);
        
        int[][] dp = new int[m + 1][n];
        dp[0][0] = 1;
        
        int mod = 1000000007;
        
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j > 0) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
                }
                if (j < n - 1) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;
                }
            }
        }
        
        return dp[m][0];
        }
    }

Runtime: 9 ms, beating 67.90% of leetcode users solutions using java.
Memory: 42.1 mb, beating 89.20% of leetcode users solutions using java.

#### Concepts Applied:

Math, dynamic programming, for loops, and if statements.

### Solution Oct 16, 2023 (Java, leetcode) 119. Pascals Triangle II (Easy) 
In .LeetcodeDailySolution folder as Oct16,2023.java

#### Prompt:

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/4de7c43b-3fb2-43b2-8d4f-806d74ff3e22)

#### Solution:

    class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<>();

        res.add(1);
        long prev = 1;

        for (int k = 1; k<= rowIndex; k++) {
            long next_val = prev * (rowIndex - k+1) / k;
            res.add((int) next_val);
            prev = next_val;

        }
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.9 mb, beating 78.30% of leetcode users solutions using java.

#### Concepts Applied:

Lists and for loop.

### Solution Oct 17, 2023 (Java, leetcode) 1361. Validate Binary Tree Nodes (Medium)
In. LeetcodeDailySolution folder as Oct17,2023.java

#### Prompt:

You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.

If node i has no left child then leftChild[i] will equal -1, similarly for the right child.

Note that the nodes have no values and that we only use the node numbers in this problem.

#### Solution:

    class Solution {
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        int[] indegree = new int[n];
        for (int i = 0; i < n; i++) {
            if (leftChild[i] != -1) indegree[leftChild[i]]++;
            if (rightChild[i] != -1) indegree[rightChild[i]]++;
        }
        int root = -1;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                if (root == -1) root = i;
                else return false;
            }
        }
        if (root == -1) return false;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (visited[node]) return false;
            visited[node] = true;
            if (leftChild[node] != -1) queue.offer(leftChild[node]);
            if (rightChild[node] != -1) queue.offer(rightChild[node]);
        }
                int trueCount = 0;
        for (boolean b : visited) {
            if (b) trueCount++;
        }
        return trueCount == n;

        }
    }

Runtime: 5 ms, beating 76.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 91.61% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statements, linked lists, and while loop.

### Solution Oct 18, 2023 (Java, leetcode) 2050, Parallel Courses III (Hard)
In .LeetcodeDailySolution folder as Oct18,2023.java

#### Prompt:

You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.

You must find the minimum number of months needed to complete all the courses following these rules:

You may start taking a course at any time if the prerequisites are met.
Any number of courses can be taken at the same time.
Return the minimum number of months needed to complete all the courses.

Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).

#### Solution:

    class Solution {
    private int[] startNodes;
    private int[][] graph;
    private int[] time;
    private boolean[] visited;
    private int[] ans;

    private void toGraph(int[][] edges, int n) {
        int[] incoming = new int[n], outgoing = new int[n];
        for(int[] e : edges) {
            outgoing[e[0] - 1]++;
            incoming[e[1] - 1]++;
        }
        int startCnt = 0;
        for(int i : incoming) {
            if (i == 0) {
                startCnt++;
            }
        }
        startNodes = new int[startCnt];
        for(int sni = 0, i = 0; sni < startNodes.length; i++) {
            if (incoming[i] == 0) {
                startNodes[sni++] = i;
            }
        }
        graph = new int[n][];
        for(int i = 0; i < n; i++) {
            graph[i] = new int[outgoing[i]];
        }
        for(int[] e : edges) {
            graph[e[0] - 1][--outgoing[e[0] - 1]] = e[1] - 1;
        }
    }

    private int calculate(int node) {
        if (ans[node] > 0) {
            return ans[node];
        }

        int worstPrereq = 0;
        visited[node] = true;
        for(int child : graph[node]) {
            if (!visited[child]){
                worstPrereq = Math.max(calculate(child), worstPrereq);
            }
        }
        visited[node] = false;
        return ans[node] = worstPrereq + time[node];
    }

    public int minimumTime(int n, int[][] relations, int[] time) {
        toGraph(relations, n);
        this.time = time;
        ans = new int[n];
        visited = new boolean[n];
        int longest = 0;
        for(int node : startNodes) {
            longest = Math.max(longest, calculate(node));
        }
        return longest;
        }
    }

Runtime: 13 ms, beating 99.56% of leetcode users solutions using java.
Memory: 68 mb, beating 56.45% of leetcode users solutions using java.

#### Concepts Applied:

Graphs, boolean, and for loops.

### Solution Oct 19, 2023 (Java, leetcode) 844. Backspace String Compare (Easy)
In .LeetcodeDailySolution folder as Oct19,2023.java

#### Prompt:

Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

#### Solution:

    class Solution {
    public boolean backspaceCompare(String s, String t) {
        int ps = s.length() - 1;
        int pt = t.length() - 1;

        while (ps >= 0 || pt >= 0) {
            ps = get_next_valid_char_index(s, ps);
            pt = get_next_valid_char_index(t, pt);

            if (ps < 0 && pt < 0) {
                return true;
            }
            if (ps < 0 || pt < 0) {
                return false;
            } else if (s.charAt(ps) != t.charAt(pt)) {
                return false;
            }

            ps--;
            pt--;
        }

        return true;        
    }

    private int get_next_valid_char_index(String str, int end) {
        int backspace_count = 0;
        while (end >= 0) {
            if (str.charAt(end) == '#') {
                backspace_count++;
            } else if (backspace_count > 0) {
                backspace_count--;
            } else {
                break;
            }
            end--;
        }
        return end;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.5 mb, beating 67.63% of leetcode users solutions using java.

#### Concepts Applied:

CharAt, while loop, if, else and else-if statements.

### Solution Oct 20, 2023 (Java, leetcode) 341. Flatten Nested List Iterator
In .LeetcodeDailySolution folder as Oct20,2023.java

#### Prompt:

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:

NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
int next() Returns the next integer in the nested list.
boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:

initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
If res matches the expected flattened list, then your code will be judged as correct.

#### Solution:

    class NestedIterator implements Iterator<Integer> {
    private Stack<NestedInteger> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack = new Stack<>();
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            stack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()) {
            if (stack.peek().isInteger()) {
                return true;
            }
            List<NestedInteger> nestedList = stack.pop().getList();
            for (int i = nestedList.size() - 1; i >= 0; i--) {
                stack.push(nestedList.get(i));
            }
        }
        return false;
        }
    }

Runtime: 4 ms, beating 25.17% of leetcode users solutions using java.
Memory: 44.26 mb, beating 74.13% of leetcode users solutions using java.

#### Concepts Applied:

NestedIterator, Iterators, Stack, nestedList, boolean, and list.

### Solution Oct 21, 2023 (Java, leetcode) 1425. Constrained Subsequence Sum (Hard)
In .LeetcodeDailySolution folder as Oct21,2023.java

#### Prompt:

Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

#### Solution:

    class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        Deque<Integer> queue = new ArrayDeque<>();
        int dp[] = new int[nums.length];
        
        for (int i = 0; i < nums.length; i++) {
            if (!queue.isEmpty() && i - queue.peek() > k) {
                queue.poll();
            }
            
            dp[i] = (!queue.isEmpty() ? dp[queue.peek()] : 0) + nums[i];
            while (!queue.isEmpty() && dp[queue.peekLast()] < dp[i]) {
                queue.pollLast();
            }
            
            if (dp[i] > 0) {
                queue.offer(i);
            }
        }
        
        int ans = Integer.MIN_VALUE;
        for (int num : dp) {
            ans = Math.max(ans, num);
        }
        
        return ans;
        }
    }

Runtime: 33 ms, beating 94.49% of leetcode users solutions using java.
Memory: 56.2 mb, beating 85.83% of leetcode users solutions using java.

#### Concepts Applied:

Deque, dynamic programming, for loop, and if statement.

### Solution Oct 22, 2023 (Java, leetcode) 1793. Maximum Score of a Good Subarray (Hard)
In .LeetcodeDailySolution folder as Oct22,2023.java

#### Prompt:

You are given an array of integers nums (0-indexed) and an integer k.

The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.

Return the maximum possible score of a good subarray.

#### Solution:

    class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int left = k;
        int right = k;
        int ans = nums[k];
        int currMin = nums[k];
        
        while (left > 0 || right < n - 1) {
            if ((left > 0 ? nums[left - 1]: 0) < (right < n - 1 ? nums[right + 1] : 0)) {
                right++;
                currMin = Math.min(currMin, nums[right]);
            } else {
                left--;
                currMin = Math.min(currMin, nums[left]);
            }
            
            ans = Math.max(ans, currMin * (right - left + 1));
        }
        
        return ans;
        }
    }    

Runtime: 7 ms, beating 88.29% of leetcode users solutions using java.
Memory: 59.22 mb, beating 39.39% of leetcode users solutions using java. 

#### Concepts Applied:

While loop, if-statement, else-statement, and math.

### Solution Oct 23, 2023 (Java, leetcode) 342. Power of Four (Easy)
In .LeetcodeDailySolution folder as Oct23,2023.java

#### Prompt:

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

#### Solution:

    class Solution {
       public boolean isPowerOfFour(int n) {
       for(int i = 2 ;i<=32;i+=2){
           if((1<<i) == n) return true;
       }
       return false;
       }
    }
    
Runtime: 1 ms, beating 76.50% of leetcode users solutions using java.
Memory: 39.00 mb, beating 93.98% of leetcode users solutions using java.

#### Concepts Applied:

For loop and if-statement.

### Solution Oct 24, 2023 (Java, leetcode) 515. Find Largest Value in Each Tree Row (Medium)
In .LeetcodeDailySolution folder as Oct24,2023.java

#### Prompt:

Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).

Example 1:

Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
Example 2:

Input: root = [1,2,3]
Output: [1,3]
 
Constraints:

The number of nodes in the tree will be in the range [0, 104].
-231 <= Node.val <= 231 - 1

#### Solution:

    class Solution {
    public List<Integer> largestValues(TreeNode root) {
       Map <Integer , Integer> map = new HashMap(); 
       dfs(root, 0, map);
       return new ArrayList(map.values());
    }

    private void dfs(TreeNode root, int level, Map<Integer , Integer> map){
        if(root==null) return;

        map.put(level, Math.max(root.val, map.getOrDefault(level, Integer.MIN_VALUE)));
        dfs(root.left, level+1, map);
        dfs(root.right, level+1, map);
        }
    }

Runtime: 1 ms, beating 98.02% of leetcode users solutions using java.
Memory: 43.94 mb, beating 61.09% of leetcode users solutions using java.

#### Concepts Applied:

Lists, HashMap, ArrayList, TreeNode, Map, Math, if-statement, and dfs. 

### Solution Oct 25, 2023 (Java, leetcode) 779. K-th Symbol in Grammar (Medium)
In .LeetcodeDailySolution folder as Oct25,2023.java

#### Prompt:

We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

#### Solution:

    class Solution {
    public int kthGrammar(int n, int k) {
        if (n == 1) {
            return 0;
        }
        
        int parent = kthGrammar(n - 1, (int) Math.ceil(k / 2.0));
        boolean isOdd = k % 2 == 1;

        if (parent == 0) {
            return isOdd ? 0 : 1;
        } else {
            return isOdd ? 1 : 0;
            }  
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.04 mb, beating 49.27% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, Math, and if-statements.

### Solution Oct 26, 2023 (Java, leetcode) 823. Binary Trees With Factors (Medium)
In .LeetcodeDailySolution folder as Oct26,2023.java

#### Prompt:

Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.

We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.

Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.

#### Solution:

public class Solution {
    private static final int MOD = 1000000007;

    public int numFactoredBinaryTrees(int[] arr) {
        Arrays.sort(arr);
        Set<Integer> s = new HashSet<>();
        for (int x : arr) s.add(x);

        Map<Integer, Integer> dp = new HashMap<>();
        for (int x : arr) dp.put(x, 1);
        
        for (int i : arr) {
            for (int j : arr) {
                if (j > Math.sqrt(i)) break;
                if (i % j == 0 && s.contains(i / j)) {
                    long temp = (long) dp.get(j) * dp.get(i / j);
                    dp.put(i, (int) ((dp.get(i) + (i / j == j ? temp : temp * 2)) % MOD));
                }
            }
        }
        
        int result = 0;
        for (int val : dp.values()) {
            result = (result + val) % MOD;
        }
        return result;
        }
    }

Runtime: 14 ms, beating 82.51% of leetcode users solutions using java.
Memory: 43.46 mb, beating 36.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Set, HashSet, for-loops, Map, HashMap, if statements, and dp.

### Solution Oct 27, 2023 (Java, leetcode) 5. Longest Palindromic String (Medium)
In .LeetcodeDailySolution folder as Oct27,2023.java

#### Prompt:

Given a string s, return the longest palindromic substring in s.

#### Solution:

    class Solution {
    public String longestPalindrome(String s) {
        StringBuilder sPrime = new StringBuilder("#");
        for (char c: s.toCharArray()) {
            sPrime.append(c).append("#");
        }
        
        int n = sPrime.length();
        int[] palindromeRadii = new int[n];
        int center = 0;
        int radius = 0;
        
        for (int i = 0; i < n; i++) {
            int mirror = 2 * center - i;
            
            if (i < radius) {
                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);
            }
            
            while (i + 1 + palindromeRadii[i] < n &&
                   i - 1 - palindromeRadii[i] >= 0 &&
                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {
                palindromeRadii[i]++;
            }
            
            if (i + palindromeRadii[i] > radius) {
                center = i;
                radius = i + palindromeRadii[i];
            }
        }
        
        int maxLength = 0;
        int centerIndex = 0;
        for (int i = 0; i < n; i++) {
            if (palindromeRadii[i] > maxLength) {
                maxLength = palindromeRadii[i];
                centerIndex = i;
            }
        }
        
        int startIndex = (centerIndex - maxLength) / 2;
        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);
        
        return longestPalindrome;
        }
    }

Runtime: 11 ms, beating 88.50% of leetcode users solutions using java.
Memory: 43.47 mb, beating 53.35% of leetcode users solutions using java.

#### Concepts Applied:

Char, charArray, for loops, if-statments, while loops, Math, charAt, strings.

### Solution Oct 28, 2023 (Java, leetcode) 1220. Count Vowels Permutation (Hard)
In .LeetcodeDailySolution folder as Oct28,2023.java

#### Prompt:

Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

#### Solution:

    class Solution {
    public int countVowelPermutation(int n) {
        final int MOD = 1000000007;

        long a = 1, e = 1, i = 1, o = 1, u = 1;

        for (int j = 1; j < n; j++) {
            long a_next = e;
            long e_next = (a + i) % MOD;
            long i_next = (a + e + o + u) % MOD;
            long o_next = (i + u) % MOD;
            long u_next = a;
            a = a_next;
            e = e_next;
            i = i_next;
            o = o_next;
            u = u_next;
            
        }
        return (int)((a + e + i + o + u) % MOD);
        }
    }

Runtime: 5 ms, beating 99.02% of leetcode users solutions using java.
Memory: 39.30 mb, beating 84.92% of leetcode users solutions using java.

#### Concepts Applied:

Long and for loop.

### Solution Oct 29, 2023 (Java, leetcode) 458. Poor Pigs (Hard)
In .LeetcodeDailySolution folder as Oct29,2023.java

#### Prompt:

There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.

You can feed the pigs according to these steps:

Choose some live pigs to feed.
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.
Wait for minutesToDie minutes. You may not feed any other pigs during this time.
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
Repeat this process until you run out of time.
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.

#### Solution:

    class Solution{
    public int poorPigs(int buckets, int tdie, int ttest){
        int test = ttest/tdie;
        int i=0;
        
        while(Math.pow(test+1,i)< buckets)
        {
            i++;
        }
        return i;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 38.70 mb, beating 95.03% of leetcode users solutions using java.

#### Concepts Applied:

Math and while loop.

### Solution Oct 30, 2023 (Java, leetcode) 1356. Sort Integers by The Number of 1 Bits (Easy)
In .LeetcodeDailySolution folder as Oct30,2023.java

#### Prompt:

You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.

Return the array after sorting it.

#### Solution:

    class Solution {
    public int[] sortByBits(int[] arr) {
        for ( int i =0 ;i< arr.length ;i++){
            arr[i] += Integer.bitCount(arr[i])*10001;
        }
        Arrays.sort(arr);
         for ( int i =0 ;i< arr.length ;i++){
             arr[i] = arr[i] %10001;
         }
        return arr;
        }
    }    

Runtime: 3 ms, beating 99.12% of leetcode users solutions using java.
Memory: 43.92 mb, beating 29.36% of leetcode users solutions using java.

#### Concepts Applied:

For loops and arrays.

### Solution Oct 31, 2023 (Java, leetcode) 2433. Find The Original Array of Prefix Xor (Medium)
In .LeetcodeDailySolution folder as Oct31,2023.java

#### Prompt:

You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:

pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
Note that ^ denotes the bitwise-xor operation.

It can be proven that the answer is unique.

#### Solution:

    class Solution {
    public int[] findArray(int[] pref) {
        int prev = pref[0];
        
        for (int i = 1; i < pref.length; i++) {
            pref[i] ^= prev;
            prev ^= pref[i];
        }
        return pref;        
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java. 
Memory: 58.68 mb, beating 54.80% of leetcode users solutions using java.

#### Concepts Applied:

findArray and for loop.

### Solution Nov 1, 2023 (Java, leetcode) 501. Find Mode in Binary Search Tree (Easy)
In .LeetcodeDailySolution folder as Nov1,2023.java

#### Prompt:

Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.

#### Solution:

    class Solution {
    private int currentVal;
    private int currentCount = 0;
    private int maxCount = 0;
    private int modeCount = 0;
    private int[] modes;
    public int[] findMode(TreeNode root) {
        inOrderTraversal(root);

        modes = new int[modeCount];
        modeCount = 0;
        currentCount = 0;

        inOrderTraversal(root);

        return modes;
    }
    private void inOrderTraversal(TreeNode node) {
        if (node == null) return;
        inOrderTraversal(node.left);
        handleValue(node.val);
        inOrderTraversal(node.right);
    }
    private void handleValue(int val) {
        if (val == currentVal) {
            currentCount++;
        } else {
            currentVal = val;
            currentCount = 1;
        }
        if (currentCount > maxCount) {
            maxCount = currentCount;
            modeCount = 1;
        } else if (currentCount == maxCount) {
            if (modes != null) {
                modes[modeCount] = currentVal;
            }
            modeCount++;
            }
        }
    }    

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.46 mb, beating 93.96% of leetcode users solutions using java.

#### Concepts Applied: 

Treenodes, traversals, if-statements, else statements, and else-if statements.

### Solution Nov 2, 2023 (Java, leetcode) 2265. Count Nodes Equal to Average of Subtree (Medium)
In .LeetcodeDailySolution folder as Nov2,2023.java

#### Prompt:

Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.

Note:

The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
A subtree of root is a tree consisting of root and all of its descendants.

#### Solution:

    class Solution {
    int count = 0;
    public int averageOfSubtree(TreeNode root) {
        dfs(root);
        return count;
    }
        private int[] dfs(TreeNode node) {
        if(node == null) {
            return new int[]{0, 0};
        } 
        int[] leftResults = dfs(node.left);
        int[] rightResults = dfs(node.right);
        
        int totalSum = node.val + leftResults[0] + rightResults[0];

        int totalCount = 1 + leftResults[1] + rightResults[1];

        if(node.val == totalSum/totalCount) count++;

        return new int[]{totalSum, totalCount};
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.40 mb, beating 95.77% of leetcode users solutions using java.

#### Concepts Applied:

dfs, Treenode, and if-statements.

### Solution Nov 4, 2023 (Java, leetcode) 1503. Last Momment Before All Ants Fall Out of a Plank (Medium)
In .LeetcodeDailySolution folder as Nov4,2023.java

#### Prompt:

We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.

When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.

Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.

#### Solution:

    class Solution {
        public int getLastMoment(int n, int[] left, int[] right) {
        int res = 0;
        for (int i: left)
            res = Math.max(res, i);
        for (int i: right)
            res = Math.max(res, n - i);
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.49 mb, beating 92.47% of leetcode users solutions using java.

#### Concepts Applied:

For loops and Math.

### Solution Nov 5, 2023 (Java, leetcode) 1535. Find the Winner of an Array Game (Medium)
In .LeetcodeDailySolution folder as Nov5,2023.java

#### Prompt:

Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.

#### Solution:

    public class Solution {
    public int getWinner(int[] A, int k) {
        int cur = A[0]; int win = 0;
        
        for (int i = 1; i < A.length; ++i) {
            if (A[i] > cur) {
                cur = A[i];
                win = 0;
            }
            if (++win == k) {
                break;
            }
        }
        return cur;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 56.40 mb, beating 69.18% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loops, and if statements. 

### Solution Nov 7, 2023 (Java, leetcode) 1921. Eliminate Maximum Number of Monsters (Medium)
In .LeetcodeDailySolution folder as Nov7,2023.java

#### Prompt:

You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.

The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.

You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.

You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.

Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

#### Solution:

    class Solution {
    public int eliminateMaximum(int[] dist, int[] speed) {
        int[] time = new int[dist.length];

        for(int i=0;i<dist.length;i++)
            time[i] = (int)Math.ceil((double)dist[i]/speed[i]);

        Arrays.sort(time);

        int ans = 0;
        int T = 0;
        for(int i=0;i<time.length;i++)
        {
            if(T++<time[i])
                ans++;
            else
                break;
        }
        return ans;
        }
    }

Runtime: 19 ms, beating 62.18% of leetcode users solutions using java.
Memory: 54.50 mb, beating 83.52% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Math, for loops, and else condition. 
